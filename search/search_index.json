{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>pg_graphql</code>","text":"<p>Documentation: https://khulnasoft.github.io/pg_graphql</p> <p>Source Code: https://github.com/khulnasoft/pg_graphql</p> <p><code>pg_graphql</code> adds GraphQL support to your PostgreSQL database.</p> <ul> <li> Performant</li> <li> Consistent</li> <li> Open Source</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p><code>pg_graphql</code> is a PostgreSQL extension that enables querying the database with GraphQL using a single SQL function.</p> <p>The extension reflects a GraphQL schema from the existing SQL schema and exposes it through a SQL function, <code>graphql.resolve(...)</code>. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries.</p>"},{"location":"#tldr","title":"TL;DR","text":"<p>The SQL schema</p> <p><pre><code>create table account(\n    id serial primary key,\n    email varchar(255) not null,\n    created_at timestamp not null,\n    updated_at timestamp not null\n);\n\ncreate table blog(\n    id serial primary key,\n    owner_id integer not null references account(id),\n    name varchar(255) not null,\n    description varchar(255),\n    created_at timestamp not null,\n    updated_at timestamp not null\n);\n\ncreate type blog_post_status as enum ('PENDING', 'RELEASED');\n\ncreate table blog_post(\n    id uuid not null default uuid_generate_v4() primary key,\n    blog_id integer not null references blog(id),\n    title varchar(255) not null,\n    body varchar(10000),\n    status blog_post_status not null,\n    created_at timestamp not null,\n    updated_at timestamp not null\n);\n</code></pre> Translates into a GraphQL schema displayed below.</p> <p>Each table receives an entrypoint in the top level <code>Query</code> type that is a pageable collection with relationships defined by its foreign keys. Tables similarly receive entrypoints in the <code>Mutation</code> type that enable bulk operations for insert, update, and delete.</p> <p></p>"},{"location":"api/","title":"API","text":"<p>In our API, each SQL table is reflected as a set of GraphQL types. At a high level, tables become types and columns/foreign keys become fields on those types.</p> <p>By default, PostgreSQL table and column names are not inflected when reflecting GraphQL  names. For example, an <code>account_holder</code> table has GraphQL type name <code>account_holder</code>. In cases where SQL entities are named using <code>snake_case</code>, enable inflection to match GraphQL/Javascript conventions e.g. <code>account_holder</code> -&gt; <code>AccountHolder</code>.</p> <p>Individual table, column, and relationship names may also be manually overridden.</p>"},{"location":"api/#primary-keys-required","title":"Primary Keys (Required)","text":"<p>Every table must have a primary key for it to be exposed in the GraphQL schema. For example, the following <code>Blog</code> table will be available in the GraphQL schema as <code>blogCollection</code> since it has a primary key named <code>id</code>:</p> <pre><code>create table \"Blog\"(\n  id serial primary key,\n  name varchar(255) not null,\n);\n</code></pre> <p>But the following table will not be exposed because it doesn't have a primary key:</p> <pre><code>create table \"Blog\"(\n  id int,\n  name varchar(255) not null,\n);\n</code></pre>"},{"location":"api/#querytype","title":"QueryType","text":"<p>The <code>Query</code> type is the entrypoint for all read access into the graph.</p>"},{"location":"api/#node","title":"Node","text":"<p>The <code>node</code> interface allows for retrieving records that are uniquely identifiable by a globally unique <code>nodeId: ID!</code> field. For more information about nodeId, see nodeId.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n  id serial primary key,\n  name varchar(255) not null,\n  description varchar(255),\n  \"createdAt\" timestamp not null,\n  \"updatedAt\" timestamp not null\n);\n</code></pre></p> <p>GraphQL Types</p> QueryType <pre><code>\"\"\"The root type for querying data\"\"\"\ntype Query {\n\n  \"\"\"Retrieve a record by its `ID`\"\"\"\n  node(nodeId: ID!): Node\n\n}\n</code></pre> <p>To query the <code>node</code> interface effectively, use inline fragments to specify which fields to return for each type.</p> <p>Example</p> QueryResponse <pre><code>{\n  node(\n    nodeId: \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\"\n  ) {\n    nodeId\n    # Inline fragment for `Blog` type\n    ... on Blog {\n      name\n      description\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"node\": {\n      \"name\": \"Some Blog\",\n      \"nodeId\": \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\",\n      \"description\": \"Description of Some Blog\"\n    }\n  }\n}\n</code></pre>"},{"location":"api/#collections","title":"Collections","text":"<p>Each table has top level entry in the <code>Query</code> type for selecting records from that table. Collections return a connection type and can be paginated, filtered, and sorted using the available arguments.</p> <p>SQL Setup</p> <pre><code>create table \"Blog\"(\n  id serial primary key,\n  name varchar(255) not null,\n  description varchar(255),\n  \"createdAt\" timestamp not null,\n  \"updatedAt\" timestamp not null\n);\n</code></pre> <p>GraphQL Types</p> QueryType <pre><code>\"\"\"The root type for querying data\"\"\"\ntype Query {\n\n  \"\"\"A pagable collection of type `Blog`\"\"\"\n  blogCollection(\n\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"\n    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.\n    \"\"\"\n    offset: Int\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n  ): BlogConnection\n}\n</code></pre> <p>Connection types are the primary interface to returning records from a collection.</p> <p>Connections wrap a result set with some additional metadata.</p> BlogConnectionBlogEdgePageInfoBlogBlogOrderByBlogFilter <pre><code>type BlogConnection {\n\n  # Count of all records matching the *filter* criteria\n  totalCount: Int!\n\n  # Pagination metadata\n  pageInfo: PageInfo!\n\n  # Result set\n  edges: [BlogEdge!]!\n\n}\n</code></pre> <pre><code>type BlogEdge {\n\n  # Unique identifier of the record within the query\n  cursor: String!\n\n  # Contents of a record/row in the results set\n  node: Blog\n\n}\n</code></pre> <pre><code>type PageInfo {\n\n  # unique identifier of the first record within the query\n  startCursor: String\n\n  # unique identifier of the last record within the query\n  endCursor: String\n\n  # is another page of content available\n  hasNextPage: Boolean!\n\n  # is another page of content available\n  hasPreviousPage: Boolean!\n}\n</code></pre> <pre><code># A record from the `blog` table\ntype Blog {\n\n  # globally unique identifier\n  nodeId: ID!\n\n  # Value from `id` column\n  id: Int!\n\n  # Value from `name` column\n  name: String!\n\n  # Value from `description` column\n  description: String\n\n  # Value from `createdAt` column\n  createdAt: Datetime!\n\n  # Value from `updatedAt` column\n  updatedAt: Datetime!\n\n}\n</code></pre> <pre><code>input BlogOrderBy {\n  id: OrderByDirection\n  name: OrderByDirection\n  description: OrderByDirection\n  createdAt: OrderByDirection\n  updatedAt: OrderByDirection\n}\n</code></pre> <pre><code>input BlogFilter {\n  nodeId: IDFilter\n  id: IntFilter\n  name: StringFilter\n  description: StringFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  and: [BlogFilter!]\n  or: [BlogFilter!]\n  not: BlogFilter\n}\n</code></pre> <p>Note</p> <p>The <code>totalCount</code> field is disabled by default because it can be expensive on large tables. To enable it use a comment directive</p>"},{"location":"api/#pagination","title":"Pagination","text":""},{"location":"api/#keyset-pagination","title":"Keyset Pagination","text":"<p>Paginating forwards and backwards through collections is handled using the <code>first</code>, <code>last</code>, <code>before</code>, and <code>after</code> parameters, following the relay spec.</p> QueryType <pre><code>type Query {\n\n  blogCollection(\n\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    ...truncated...\n\n  ): BlogConnection\n}\n</code></pre> <p>Metadata relating to the current page of a result set is available on the <code>pageInfo</code> field of the connection type returned from a collection.</p> PageInfoBlogConnection <pre><code>type PageInfo {\n\n  # unique identifier of the first record within the query\n  startCursor: String\n\n  # unique identifier of the last record within the query\n  endCursor: String\n\n  # is another page of content available\n  hasNextPage: Boolean!\n\n  # is another page of content available\n  hasPreviousPage: Boolean!\n}\n</code></pre> <pre><code>type BlogConnection {\n\n  # Pagination metadata\n  pageInfo: PageInfo!\n\n  # Result set\n  edges: [BlogEdge!]!\n\n}\n</code></pre> <p>To paginate forward in the collection, use the <code>first</code> and <code>after</code> arguments. To retrieve the first page, the <code>after</code> argument should be null or absent.</p> <p>Example</p> QueryPage 1 <pre><code>{\n  blogCollection(\n    first: 2,\n    after: null\n  ) {\n    pageInfo {\n      startCursor\n      endCursor\n      hasPreviousPage\n      hasNextPage\n    }\n    edges {\n      cursor\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2\n          },\n          \"cursor\": \"WzJd\"\n        }\n      ],\n      \"pageInfo\": {\n        \"startCursor\": \"WzFd\",\n        \"endCursor\": \"WzJd\",\n        \"hasNextPage\": true,\n        \"hasPreviousPage\": false\n      }\n    }\n  }\n}\n</code></pre> <p>To retrieve the next page, provide the cursor value from <code>data.blogCollection.pageInfo.endCursor</code> to the <code>after</code> argument of another query.</p> QueryPage 2 <pre><code>{\n  blogCollection(\n    first: 2,\n    after: \"WzJd\"\n  ) {\n  ...truncated...\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 3\n          },\n          \"cursor\": \"WzNd\"\n        },\n        {\n          \"node\": {\n            \"id\": 4\n          },\n          \"cursor\": \"WzRd\"\n        }\n      ],\n      \"pageInfo\": {\n        \"startCursor\": \"WzNd\",\n        \"endCursor\": \"WzRd\",\n        \"hasNextPage\": false,\n        \"hasPreviousPage\": true\n      }\n    }\n  }\n}\n</code></pre> <p>once the collection has been fully enumerated, <code>data.blogConnection.pageInfo.hasNextPage</code> returns false.</p> <p>To paginate backwards through a collection, repeat the process substituting <code>first</code> -&gt; <code>last</code>, <code>after</code> -&gt; <code>before</code>, <code>hasNextPage</code> -&gt; <code>hasPreviousPage</code></p>"},{"location":"api/#offset-pagination","title":"Offset Pagination","text":"<p>In addition to keyset pagination, collections may also be paged using <code>first</code> and <code>offset</code>, which operates like SQL's <code>limit</code> and <code>offset</code> to skip <code>offset</code> number of records in the results.</p> <p>Note</p> <p><code>offset</code> based pagination becomes inefficient the <code>offset</code> value increases. For this reason, prefer cursor based pagination where possible.</p> QueryPage 2 <pre><code>{\n  blogCollection(\n    first: 2,\n    offset: 2\n  ) {\n  ...truncated...\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 3\n          },\n          \"cursor\": \"WzNd\"\n        },\n        {\n          \"node\": {\n            \"id\": 4\n          },\n          \"cursor\": \"WzRd\"\n        }\n      ],\n      \"pageInfo\": {\n        \"startCursor\": \"WzNd\",\n        \"endCursor\": \"WzRd\",\n        \"hasNextPage\": false,\n        \"hasPreviousPage\": true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"api/#filtering","title":"Filtering","text":"<p>To filter the result set, use the <code>filter</code> argument.</p> QueryType <pre><code>type Query {\n\n  blogCollection(\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    ...truncated...\n\n  ): BlogConnection\n}\n</code></pre> <p>Where the <code>&lt;Table&gt;Filter</code> type enumerates filterable fields and their associated <code>&lt;Type&gt;Filter</code>.</p> BlogFilterIntFilterStringFilterStringListFilterFilterIs <pre><code>input BlogFilter {\n  nodeId: IDFilter\n  id: IntFilter\n  name: StringFilter\n  description: StringFilter\n  tags: StringListFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  and: [BlogFilter!]\n  or: [BlogFilter!]\n  not: BlogFilter\n}\n</code></pre> <pre><code>\"\"\"\nBoolean expression comparing fields on type \"Int\"\n\"\"\"\ninput IntFilter {\n  eq: Int\n  gt: Int\n  gte: Int\n  in: [Int!]\n  lt: Int\n  lte: Int\n  neq: Int\n  is: FilterIs\n}\n</code></pre> <pre><code>\"\"\"\nBoolean expression comparing fields on type \"String\"\n\"\"\"\ninput StringFilter {\n  eq: String\n  gt: String\n  gte: String\n  in: [String!]\n  lt: String\n  lte: String\n  neq: String\n  is: FilterIs\n  startsWith: String\n  like: String\n  ilike: String\n  regex: String\n  iregex: String\n}\n</code></pre> <pre><code>\"\"\"\nBoolean expression comparing fields on type \"StringList\"\n\"\"\"\ninput StringListFilter {\n  contains: [String!]\n  containedBy: [String!]\n  eq: [String!]\n  overlaps: [String!]\n  is: FilterIs\n}\n</code></pre> <pre><code>enum FilterIs {\n  NULL\n  NOT_NULL\n}\n</code></pre> <p>The following list shows the operators that may be available on <code>&lt;Type&gt;Filter</code> types.</p> Operator Description eq Equal To neq Not Equal To gt Greater Than gte Greater Than Or Equal To in Contained by Value List lt Less Than lte Less Than Or Equal To is Null or Not Null startsWith Starts with prefix like Pattern Match. '%' as wildcard ilike Pattern Match. '%' as wildcard. Case Insensitive regex POSIX Regular Expression Match iregex POSIX Regular Expression Match. Case Insensitive contains Contains. Applies to array columns only. containedBy Contained in. Applies to array columns only. overlaps Overlap (have points in common). Applies to array columns only. <p>Not all operators are available on every <code>&lt;Type&gt;Filter</code> type. For example, <code>UUIDFilter</code> only supports <code>eq</code> and <code>neq</code> because <code>UUID</code>s are not ordered.</p> <p>Example: simple</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {id: {lt: 3}},\n  ) {\n    edges {\n      cursor\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2\n          },\n          \"cursor\": \"WzJd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Example: array column</p> <p>The <code>contains</code> filter is used to return results where all the elements in the input array appear in the array column.</p> <code>contains</code> Filter Query<code>contains</code> Filter Result <pre><code>{\n  blogCollection(\n    filter: {tags: {contains: [\"tech\", \"innovation\"]}},\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        tags\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"tech\", \"innovation\"]\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"tech\", \"innovation\", \"entrepreneurship\"]\n          },\n          \"cursor\": \"WzJd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>The <code>contains</code> filter can also accept a single scalar.</p> <code>contains</code> Filter with Scalar Query<code>contains</code> Filter with Scalar Result <pre><code>{\n  blogCollection(\n    filter: {tags: {contains: \"tech\"}},\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        tags\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"tech\", \"innovation\"]\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"tech\", \"innovation\", \"entrepreneurship\"]\n          },\n          \"cursor\": \"WzJd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>The <code>containedBy</code> filter is used to return results where every element of the array column appears in the input array.</p> <code>containedBy</code> Filter Query<code>containedBy</code> Filter Result <pre><code>{\n  blogCollection(\n    filter: {tags: {containedBy: [\"entrepreneurship\", \"innovation\", \"tech\"]}},\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        tags\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"tech\", \"innovation\"]\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 3,\n            \"name\": \"A: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"innovation\", \"entrepreneurship\"]\n          },\n          \"cursor\": \"WzNd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>The <code>containedBy</code> filter can also accept a single scalar. In this case, only results where the only element in the array column is the input scalar are returned.</p> <code>containedBy</code> Filter with Scalar Query<code>containedBy</code> Filter with Scalar Result <pre><code>{\n  blogCollection(\n    filter: {tags: {containedBy: \"travel\"}},\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        tags\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 4,\n            \"name\": \"A: Blog 4\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"travel\"]\n          },\n          \"cursor\": \"WzPd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>The <code>overlaps</code> filter is used to return results where the array column and the input array have at least one element in common.</p> <code>overlaps</code> Filter Query<code>overlaps</code> Filter Result <pre><code>{\n  blogCollection(\n    filter: {tags: {overlaps: [\"tech\", \"travel\"]}},\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        tags\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"tech\", \"innovation\"]\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"tech\", \"innovation\", \"entrepreneurship\"]\n          },\n          \"cursor\": \"WzJd\"\n        },\n        {\n          \"node\": {\n            \"id\": 4,\n            \"name\": \"A: Blog 4\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"tags\": [\"travel\"]\n          },\n          \"cursor\": \"WzPd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Example: and/or</p> <p>Multiple filters can be combined with <code>and</code>, <code>or</code> and <code>not</code> operators. The <code>and</code> and <code>or</code> operators accept a list of <code>&lt;Type&gt;Filter</code>.</p> <code>and</code> Filter Query<code>and</code> Filter Result<code>or</code> Filter Query<code>or</code> Filter Result <pre><code>{\n  blogCollection(\n    filter: {\n      and: [\n        {id: {eq: 1}}\n        {name: {eq: \"A: Blog 1\"}}\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc1\"\n          },\n          \"cursor\": \"WzFd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <pre><code>{\n  blogCollection(\n    filter: {\n      or: [\n        {id: {eq: 1}}\n        {name: {eq: \"A: Blog 2\"}}\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc1\"\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc2\"\n          },\n          \"cursor\": \"WzJd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Example: not</p> <p><code>not</code> accepts a single <code>&lt;Type&gt;Filter</code>.</p> <code>not</code> Filter Query<code>not</code> Filter Result <pre><code>{\n  blogCollection(\n    filter: {\n      not: {id: {eq: 1}}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc2\"\n          },\n          \"cursor\": \"WzJd\"\n        },\n        {\n          \"node\": {\n            \"id\": 3,\n            \"name\": \"A: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc3\"\n          },\n          \"cursor\": \"WzNd\"\n        },\n        {\n          \"node\": {\n            \"id\": 4,\n            \"name\": \"B: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"b desc1\"\n          },\n          \"cursor\": \"WzRd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Example: nested composition</p> <p>The <code>and</code>, <code>or</code> and <code>not</code> operators can be arbitrarily nested inside each other.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      or: [\n        { id: { eq: 1 } }\n        { id: { eq: 2 } }\n        { and: [{ id: { eq: 3 }, not: { name: { eq: \"A: Blog 2\" } } }] }\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc1\"\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc2\"\n          },\n          \"cursor\": \"WzJd\"\n        },\n        {\n          \"node\": {\n            \"id\": 3,\n            \"name\": \"A: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc3\"\n          },\n          \"cursor\": \"WzNd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Example: empty</p> <p>Empty filters are ignored, i.e. they behave as if the operator was not specified at all.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      and: [], or: [], not: {}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"A: Blog 1\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc1\"\n          },\n          \"cursor\": \"WzFd\"\n        },\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc2\"\n          },\n          \"cursor\": \"WzJd\"\n        },\n        {\n          \"node\": {\n            \"id\": 3,\n            \"name\": \"A: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc3\"\n          },\n          \"cursor\": \"WzNd\"\n        },\n        {\n          \"node\": {\n            \"id\": 4,\n            \"name\": \"B: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"b desc1\"\n          },\n          \"cursor\": \"WzRd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Example: implicit and</p> <p>Multiple column filters at the same level will be implicitly combined with boolean <code>and</code>. In the following example the <code>id: {eq: 1}</code> and <code>name: {eq: \"A: Blog 1\"}</code> will be <code>and</code>ed.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      # Equivalent to not: { and: [{id: {eq: 1}}, {name: {eq: \"A: Blog 1\"}}]}\n      not: {\n        id: {eq: 1}\n        name: {eq: \"A: Blog 1\"}\n      }\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc2\"\n          },\n          \"cursor\": \"WzJd\"\n        },\n        {\n          \"node\": {\n            \"id\": 3,\n            \"name\": \"A: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc3\"\n          },\n          \"cursor\": \"WzNd\"\n        },\n        {\n          \"node\": {\n            \"id\": 4,\n            \"name\": \"B: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"b desc1\"\n          },\n          \"cursor\": \"WzRd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>This means that an <code>and</code> filter can be often be simplified. In the following example all queries are equivalent and produce the same result.</p> Original <code>and</code> QuerySimplified <code>and</code> QueryEven More Simplified QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      and: [\n        {id: {gt: 0}}\n        {id: {lt: 2}}\n        {name: {eq: \"A: Blog 1\"}}\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  blogCollection(\n    filter: {\n        id: {gt: 0}\n        id: {lt: 2}\n        name: {eq: \"A: Blog 1\"}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  blogCollection(\n    filter: {\n        id: {gt: 0, lt: 2}\n        name: {eq: \"A: Blog 1\"}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 2,\n            \"name\": \"A: Blog 2\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc2\"\n          },\n          \"cursor\": \"WzJd\"\n        },\n        {\n          \"node\": {\n            \"id\": 3,\n            \"name\": \"A: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"a desc3\"\n          },\n          \"cursor\": \"WzNd\"\n        },\n        {\n          \"node\": {\n            \"id\": 4,\n            \"name\": \"B: Blog 3\",\n            \"createdAt\": \"2023-07-24T04:01:09.882781\",\n            \"description\": \"b desc1\"\n          },\n          \"cursor\": \"WzRd\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Be aware that the above simplification only works for the <code>and</code> operator. If you try it with an <code>or</code> operator it will behave like an <code>and</code>.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      # This is really an `and` in `or`'s clothing\n      or: {\n        id: {eq: 1}\n        name: {eq: \"A: Blog 2\"}\n      }\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": []\n    }\n  }\n}\n</code></pre> <p>This is because according to the rules of GraphQL list input coercion, if a value passed to an input of list type is not a list, then it is coerced to a list of a single item. So in the above example <code>or: {id: {eq: 1}, name: {eq: \"A: Blog 2}}</code> will be coerced into <code>or: [{id: {eq: 1}, name: {eq: \"A: Blog 2}}]</code> which is equivalent to <code>or: [and: [{id: {eq: 1}}, {name: {eq: \"A: Blog 2}}}]</code> due to implicit <code>and</code>ing.</p> <p>Note</p> <p>Avoid naming your columns <code>and</code>, <code>or</code> or <code>not</code>. If you do, the corresponding filter operator will not be available for use.</p> <p>The <code>and</code>, <code>or</code> and <code>not</code> operators also work with update and delete mutations.</p>"},{"location":"api/#ordering","title":"Ordering","text":"<p>The default order of results is defined by the underlying table's primary key column in ascending order. That default can be overridden by passing an array of <code>&lt;Table&gt;OrderBy</code> to the collection's <code>orderBy</code> argument.</p> QueryTypeBlogOrderByOrderByDirection <pre><code>type Query {\n\n  blogCollection(\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n\n    ...truncated...\n\n  ): BlogConnection\n}\n</code></pre> <pre><code>input BlogOrderBy {\n  id: OrderByDirection\n  name: OrderByDirection\n  description: OrderByDirection\n  createdAt: OrderByDirection\n  updatedAt: OrderByDirection\n}\n</code></pre> <pre><code>\"\"\"Defines a per-field sorting order\"\"\"\nenum OrderByDirection {\n  \"\"\"Ascending order, nulls first\"\"\"\n  AscNullsFirst\n\n  \"\"\"Ascending order, nulls last\"\"\"\n  AscNullsLast\n\n  \"\"\"Descending order, nulls first\"\"\"\n  DescNullsFirst\n\n  \"\"\"Descending order, nulls last\"\"\"\n  DescNullsLast\n}\n</code></pre> <p>Example</p> QueryResult <pre><code>{\n  blogCollection(\n    orderBy: [{id: DescNullsLast}]\n  ) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 4\n          }\n        },\n        {\n          \"node\": {\n            \"id\": 3\n          }\n        },\n        {\n          \"node\": {\n            \"id\": 2\n          }\n        },\n        {\n          \"node\": {\n            \"id\": 1\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Note, only one key value pair may be provided to each element of the input array. For example, <code>[{name: AscNullsLast}, {id: AscNullFirst}]</code> is valid. Passing multiple key value pairs in a single element of the input array e.g. <code>[{name: AscNullsLast, id: AscNullFirst}]</code>, is invalid.</p>"},{"location":"api/#mutationtype","title":"MutationType","text":"<p>The <code>Mutation</code> type is the entrypoint for mutations/edits.</p> <p>Each table has top level entry in the <code>Mutation</code> type for inserting <code>insertInto&lt;Table&gt;Collection</code>, updating <code>update&lt;Table&gt;Collection</code> and deleting <code>deleteFrom&lt;Table&gt;Collection</code>.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n  id serial primary key,\n  name varchar(255) not null,\n  description varchar(255),\n  \"createdAt\" timestamp not null default now(),\n  \"updatedAt\" timestamp\n);\n</code></pre></p> MutationType <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\"\n  insertIntoBlogCollection(\n\n    \"\"\"Records to add to the Blog collection\"\"\"\n    objects: [BlogInsertInput!]!\n\n  ): BlogInsertResponse\n\n  \"\"\"Updates zero or more records in the collection\"\"\"\n  updateBlogCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogUpdateResponse!\n\n  \"\"\"Deletes zero or more records from the collection\"\"\"\n  deleteFromBlogCollection(\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogDeleteResponse!\n\n}\n</code></pre>"},{"location":"api/#insert","title":"Insert","text":"<p>To add records to a collection, use the <code>insertInto&lt;Table&gt;Collection</code> field on the <code>Mutation</code> type.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n  id serial primary key,\n  name varchar(255) not null,\n  description varchar(255),\n  \"createdAt\" timestamp not null default now(),\n  \"updatedAt\" timestamp\n);\n</code></pre></p> <p>GraphQL Types</p> MutationTypeBlogInsertInputBlogInsertResponse <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\"\n  insertIntoBlogCollection(\n\n    \"\"\"Records to add to the Blog collection\"\"\"\n    objects: [BlogInsertInput!]!\n\n  ): BlogInsertResponse\n\n}\n</code></pre> <pre><code>input BlogInsertInput {\n  name: String\n  description: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n</code></pre> <pre><code>type BlogInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n</code></pre> <p>Where elements in the <code>objects</code> array are inserted into the underlying table.</p> <p>Example</p> QueryResult <pre><code>mutation {\n  insertIntoBlogCollection(\n    objects: [\n      {name: \"foo\"},\n      {name: \"bar\"},\n    ]\n  ) {\n    affectedCount\n    records {\n      id\n      name\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"insertIntoBlogCollection\": {\n      \"records\": [\n        {\n          \"id\": 1,\n          \"name\": \"foo\"\n        },\n        {\n          \"id\": 2,\n          \"name\": \"bar\"\n        }\n      ],\n      \"affectedCount\": 2\n    }\n  }\n}\n</code></pre>"},{"location":"api/#update","title":"Update","text":"<p>To update records in a collection, use the <code>update&lt;Table&gt;Collection</code> field on the <code>Mutation</code> type.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n  id serial primary key,\n  name varchar(255) not null,\n  description varchar(255),\n  \"createdAt\" timestamp not null default now(),\n  \"updatedAt\" timestamp\n);\n</code></pre></p> <p>GraphQL Types</p> MutationTypeBlogUpdateInputBlogUpdateResponse <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Updates zero or more records in the collection\"\"\"\n  updateBlogCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogUpdateResponse!\n\n}\n</code></pre> <pre><code>input BlogUpdateInput {\n  name: String\n  description: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n</code></pre> <pre><code>type BlogUpdateResponse {\n\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n\n}\n</code></pre> <p>Where the <code>set</code> argument is a key value pair describing the values to update, <code>filter</code> controls which records should be updated, and <code>atMost</code> restricts the maximum number of records that may be impacted. If the number of records impacted by the mutation exceeds the <code>atMost</code> parameter the operation will return an error.</p> <p>Example</p> QueryResult <pre><code>mutation {\n  updateBlogCollection(\n    set: {name: \"baz\"}\n    filter: {id: {eq: 1}}\n  ) {\n    affectedCount\n    records {\n      id\n      name\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"updateBlogCollection\": {\n      \"records\": [\n        {\n          \"id\": 1,\n          \"name\": \"baz\"\n        }\n      ],\n      \"affectedCount\": 1\n    }\n  }\n}\n</code></pre>"},{"location":"api/#delete","title":"Delete","text":"<p>To remove records from a collection, use the <code>deleteFrom&lt;Table&gt;Collection</code> field on the <code>Mutation</code> type.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n  id serial primary key,\n  name varchar(255) not null,\n  description varchar(255),\n  \"createdAt\" timestamp not null default now(),\n  \"updatedAt\" timestamp\n);\n</code></pre></p> <p>GraphQL Types</p> MutationTypeBlogFilterBlogDeleteResponse <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Deletes zero or more records from the collection\"\"\"\n  deleteFromBlogCollection(\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogDeleteResponse!\n\n}\n</code></pre> <pre><code>input BlogFilter {\n  id: IntFilter\n  name: StringFilter\n  description: StringFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  and: [BlogFilter!]\n  or: [BlogFilter!]\n  not: BlogFilter\n}\n</code></pre> <pre><code>type BlogDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n</code></pre> <p>Where <code>filter</code> controls which records should be deleted and <code>atMost</code> restricts the maximum number of records that may be deleted. If the number of records impacted by the mutation exceeds the <code>atMost</code> parameter the operation will return an error.</p> <p>Example</p> QueryResult <pre><code>mutation {\n  deleteFromBlogCollection(\n    filter: {id: {eq: 1}}\n  ) {\n    affectedCount\n    records {\n      id\n      name\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"deleteFromBlogCollection\": {\n      \"records\": [\n        {\n          \"id\": 1,\n          \"name\": \"baz\"\n        }\n      ],\n      \"affectedCount\": 1\n    }\n  }\n}\n</code></pre>"},{"location":"api/#concepts","title":"Concepts","text":""},{"location":"api/#nodeid","title":"nodeId","text":"<p>The base GraphQL type for every table with a primary key is automatically assigned a <code>nodeId: ID!</code> field. That value, can be passed to the node entrypoint of the <code>Query</code> type to retrieve its other fields. <code>nodeId</code> may also be used as a caching key.</p> <p>relay support</p> <p>By default relay expects the <code>ID</code> field for types to have the name <code>id</code>. pg_graphql uses <code>nodeId</code> by default to avoid conflicting with user defined <code>id</code> columns. You can configure relay to work with pg_graphql's <code>nodeId</code> field with relay's <code>nodeInterfaceIdField</code> option. More info available here.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n    id serial primary key,\n    name varchar(255) not null\n);\n</code></pre></p> <p>GraphQL Types</p> Blog <pre><code>type Blog {\n  nodeId: ID! # this field\n  id: Int!\n  name: String!\n}\n</code></pre>"},{"location":"api/#relationships","title":"Relationships","text":"<p>Relationships between collections in the Graph are derived from foreign keys.</p>"},{"location":"api/#one-to-many","title":"One-to-Many","text":"<p>A foreign key on table A referencing table B defines a one-to-many relationship from table A to table B.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n    id serial primary key,\n    name varchar(255) not null\n);\n\ncreate table \"BlogPost\"(\n    id serial primary key,\n    \"blogId\" integer not null references \"Blog\"(id),\n    title varchar(255) not null,\n    body varchar(10000)\n);\n</code></pre></p> <p>GraphQL Types</p> Blog <pre><code>type Blog {\n\n  # globally unique identifier\n  nodeId: ID!\n\n  id: Int!\n  name: String!\n  description: String\n\n  blogPostCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"\n    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.\n    \"\"\"\n    offset: Int\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogPostOrderBy!]\n  ): BlogPostConnection\n\n}\n</code></pre> <p>Where <code>blogPostCollection</code> exposes the full <code>Query</code> interface to <code>BlogPost</code>s.</p> <p>Example</p> QueryResult <pre><code>{\n  blogCollection {\n    edges {\n      node {\n        name\n        blogPostCollection {\n          edges {\n            node {\n              id\n              title\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"name\": \"pg_graphql blog\",\n            \"blogPostCollection\": {\n              \"edges\": [\n                {\n                  \"node\": {\n                    \"id\": 2,\n                    \"title\": \"fIr3t p0sT\"\n                  }\n                },\n                {\n                  \"node\": {\n                    \"id\": 3,\n                    \"title\": \"graphql with postgres\"\n                  }\n                }\n              ]\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"api/#many-to-one","title":"Many-to-One","text":"<p>A foreign key on table A referencing table B defines a many-to-one relationship from table B to table A.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\n    id serial primary key,\n    name varchar(255) not null\n);\n\ncreate table \"BlogPost\"(\n    id serial primary key,\n    \"blogId\" integer not null references \"Blog\"(id),\n    title varchar(255) not null,\n    body varchar(10000)\n);\n</code></pre></p> <p>GraphQL Types</p> BlogPost <pre><code>type BlogPost {\n  nodeId: ID!\n  id: Int!\n  blogId: Int!\n  title: String!\n  body: String\n\n  blog: Blog\n}\n</code></pre> <p>Where <code>blog</code> exposes the <code>Blog</code> record associated with the <code>BlogPost</code>.</p> QueryResult <pre><code>{\n  blogPostCollection {\n    edges {\n      node {\n        title\n        blog {\n          name\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"blogPostCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"blog\": {\n              \"name\": \"pg_graphql blog\"\n            },\n            \"title\": \"fIr3t p0sT\"\n          }\n        },\n        {\n          \"node\": {\n            \"blog\": {\n              \"name\": \"pg_graphql blog\"\n            },\n            \"title\": \"graphql with postgres\"\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"api/#one-to-one","title":"One-to-One","text":"<p>A one-to-one relationship is defined by a foreign key on table A referencing table B where the columns making up the foreign key on table A are unique.</p> <p>SQL Setup <pre><code>create table \"EmailAddress\"(\n    id serial primary key,\n    address text unique not null\n);\n\ncreate table \"Employee\"(\n    id serial primary key,\n    name text not null,\n    email_address_id int unique references \"EmailAddress\"(id)\n);\n</code></pre></p> <p>GraphQL Types</p> EmployeeEmailAddress <pre><code>type Employee {\n  nodeId: ID!\n  id: Int!\n  name: String!\n  emailAddressId: Int\n  emailAddress: EmailAddress\n}\n</code></pre> <pre><code>type EmailAddress {\n  nodeId: ID!\n  id: Int!\n  address: String!\n  employee: Employee\n}\n</code></pre> <p>Example</p> QueryResult <pre><code>{\n  employeeCollection {\n    edges {\n      node {\n        name\n        emailAddress {\n          address\n          employee {\n            name\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"employeeCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"name\": \"Foo Barington\",\n            \"emailAddress\": {\n              \"address\": \"foo@bar.com\",\n              \"employee\": {\n                \"name\": \"Foo Barington\"\n              }\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"api/#custom-scalars","title":"Custom Scalars","text":"<p>Due to differences among the types supported by PostgreSQL, JSON, and GraphQL, <code>pg_graphql</code> adds several new Scalar types to handle PostgreSQL builtins that require special handling.</p>"},{"location":"api/#json","title":"JSON","text":"<p><code>pg_graphql</code> serializes <code>json</code> and <code>jsonb</code> data types as <code>String</code> under the custom scalar name <code>JSON</code>.</p> <pre><code>scalar JSON\n</code></pre> <p>Example</p> <p>Given the setup</p> SQLGraphQL <pre><code>create table \"User\"(\n    id bigserial primary key,\n    config jsonb\n);\n\ninsert into \"User\"(config)\nvalues (jsonb_build_object('palette', 'dark-mode'));\n</code></pre> <pre><code>type User {\n  nodeId: ID!\n  id: BigInt!\n  config: JSON\n}\n</code></pre> <p>The query</p> <pre><code>{\n  userCollection {\n    edges {\n      node {\n        config\n      }\n    }\n  }\n}\n</code></pre> <p>The returns the following data. Note that <code>config</code> is serialized as a string</p> <pre><code>{\n  \"data\": {\n    \"userCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"config\": \"{\\\"palette\\\": \\\"dark-mode\\\"}\"\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Use serialized JSON strings when updating or inserting <code>JSON</code> fields via the GraphQL API.</p> <p>JSON does not currently support filtering.</p>"},{"location":"api/#bigint","title":"BigInt","text":"<p>PostgreSQL <code>bigint</code> and <code>bigserial</code> types are 64 bit integers. In contrast, JSON supports 32 bit integers.</p> <p>Since PostgreSQL <code>bigint</code> values may be outside the min/max range allowed by JSON, they are represented in the GraphQL schema as <code>BigInt</code>s and values are serialized as strings.</p> <pre><code>scalar BigInt\n\ninput BigIntFilter {\n  eq: BigInt\n  gt: BigInt\n  gte: BigInt\n  in: [BigInt!]\n  lt: BigInt\n  lte: BigInt\n  neq: BigInt\n  is: FilterIs\n}\n</code></pre> <p>Example</p> <p>Given the setup</p> SQLGraphQL <pre><code>create table \"Person\"(\n    id bigserial primary key,\n    name text\n);\n\ninsert into \"Person\"(name)\nvalues ('J. Bazworth');\n</code></pre> <pre><code>type Person {\n  nodeId: ID!\n  id: BigInt!\n  name: String\n}\n</code></pre> <p>The query</p> <pre><code>{\n  personCollection {\n    edges {\n      node {\n        id\n        name\n      }\n    }\n  }\n}\n</code></pre> <p>The returns the following data. Note that <code>id</code> is serialized as a string</p> <pre><code>{\n  \"data\": {\n    \"personCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": \"1\",\n            \"name\": \"Foo Barington\",\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"api/#bigfloat","title":"BigFloat","text":"<p>PostgreSQL's <code>numeric</code> type supports arbitrary precision floating point values. JSON's <code>float</code> is limited to 64-bit precision.</p> <p>Since a PostgreSQL <code>numeric</code> may require more precision than can be handled by JSON, <code>numeric</code> types are represented in the GraphQL schema as <code>BigFloat</code> and values are serialized as strings.</p> <pre><code>scalar BigFloat\n\ninput BigFloatFilter {\n  eq: BigFloat\n  gt: BigFloat\n  gte: BigFloat\n  in: [BigFloat!]\n  lt: BigFloat\n  lte: BigFloat\n  neq: BigFloat\n  is: FilterIs\n}\n</code></pre> <p>Example</p> <p>Given the SQL setup</p> <pre><code>create table \"GeneralLedger\"(\n    id serial primary key,\n    amount numeric(10,2)\n);\n\ninsert into \"GeneralLedger\"(amount)\nvalues (22.15);\n</code></pre> <p>The query</p> <pre><code>{\n  generalLedgerCollection {\n    edges {\n      node {\n        id\n        amount\n      }\n    }\n  }\n}\n</code></pre> <p>The returns the following data. Note that <code>amount</code> is serialized as a string</p> <pre><code>{\n  \"data\": {\n    \"generalLedgerCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"amount\": \"22.15\",\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"api/#opaque","title":"Opaque","text":"<p>PostgreSQL's type system is extensible and not all types handle all operations e.g. filtering with <code>like</code>. To account for these, <code>pg_graphql</code> introduces a scalar <code>Opaque</code> type. The <code>Opaque</code> type uses PostgreSQL's <code>to_json</code> method to serialize values. That allows complex or unknown types to be included in the schema by delegating handling to the client.</p> <pre><code>scalar Opaque\n\ninput OpaqueFilter {\n  eq: Opaque\n  is: FilterIs\n}\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#100","title":"1.0.0","text":"<ul> <li>Initial release</li> </ul>"},{"location":"changelog/#101","title":"1.0.1","text":"<ul> <li>feature: Add support for Postgres 15</li> </ul>"},{"location":"changelog/#102","title":"1.0.2","text":"<ul> <li>bugfix: Correct inconsistent treatment of null literals</li> </ul>"},{"location":"changelog/#110","title":"1.1.0","text":"<ul> <li>feature: Add support for Views, Materialized Views, and Foreign Tables</li> <li>feature: Add support for filtering on <code>is null</code> and <code>is not null</code></li> <li>feature: User configurable page size</li> <li>bugfix: Remove requirement for <code>insert</code> permission on every column for inserts to succeed</li> <li>bugfix: <code>hasNextPage</code> and <code>hasPreviousPage</code> during reverse pagination were backwards</li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":"<ul> <li>feature: <code>String</code> type filters support <code>ilike</code>, <code>like</code>, <code>startsWith</code></li> <li>feature: Support for <code>@skip</code> and <code>@include</code> directives</li> <li>feature: Custom descriptions via comment directive <code>@graphql({\"description\": ...})</code></li> <li>bugfix: Unknown types are represented in GraphQL schema as <code>Opaque</code> rather than <code>String</code></li> <li>bugfix: PostgreSQL type modifiers, e.g. char(n), no longer truncate excess text</li> <li>bugfix: Creating a new enum variant between existing variants no longer errors</li> </ul>"},{"location":"changelog/#121","title":"1.2.1","text":"<ul> <li>feature: <code>String</code> type filters support <code>regex</code>, <code>iregex</code></li> <li>feature: computed relationships via functions returning setof</li> <li>bugfix: function based computed columns with same name no longer error</li> </ul>"},{"location":"changelog/#122","title":"1.2.2","text":"<ul> <li>feature: reproducible builds</li> </ul>"},{"location":"changelog/#123","title":"1.2.3","text":"<ul> <li>bugfix: enums not on the roles <code>search_path</code> are excluded from introspection</li> <li>bugfix: remove duplicate Enum registration</li> <li>bugfix: foreign keys on non-null columns produce non-null GraphQL relationships</li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":"<ul> <li>feature: rename enum variants with comment directive <code>@graphql({\"mappings\": \"sql-value\": \"graphql_value\"\"})</code></li> <li>bugfix: query with more than 50 fields fails</li> <li>bugfix: @skip and @include directives missing from introspection schema</li> <li>feature: Support for <code>and</code>, <code>or</code> and <code>not</code> operators in filters</li> <li>bugfix: queries failed to run if the database was in read-only replica mode</li> </ul>"},{"location":"changelog/#140","title":"1.4.0","text":"<ul> <li>feature: citext type represented as a GraphQL String</li> <li>feature: Support for Postgres 16</li> <li>feature: Support for user defined functions</li> </ul>"},{"location":"changelog/#141","title":"1.4.1","text":"<ul> <li>feature: Support for user defined functions with default arguments</li> <li>bugfix: Trigger functions excluded from API</li> </ul>"},{"location":"changelog/#142","title":"1.4.2","text":"<ul> <li>bugfix: UDF call returned null if the row returned by the function had any null column</li> </ul>"},{"location":"changelog/#143","title":"1.4.3","text":"<ul> <li>bugfix: make non-default args non-null in UDFs</li> <li>bugfix: default value of a string type argument in a UDF was wrapped in single quotes</li> <li>feature: add support for array types in UDFs</li> <li>bugfix: fix crash when there are cycles in fragments</li> <li>bugfix: function returning an inaccessible table's type no longer breaks introspection</li> </ul>"},{"location":"changelog/#144","title":"1.4.4","text":"<ul> <li>bugfix: function returning a noncompliant view's type no longer breaks introspection</li> </ul>"},{"location":"changelog/#150","title":"1.5.0","text":"<ul> <li>feature: <code>first</code>/<code>offset</code> based pagination</li> <li>feature: improved descriptions for all internal error states</li> </ul>"},{"location":"changelog/#151","title":"1.5.1","text":"<ul> <li>bugfix: reimplemented field merging to resolve a performance issue on large queries</li> </ul>"},{"location":"changelog/#152","title":"1.5.2","text":"<ul> <li>bugfix: enabled schema based multi-tenancy via filtering SQL context on schema permissions</li> <li>bugfix: function arguments with a null default value were required instead of optional</li> </ul>"},{"location":"changelog/#153","title":"1.5.3","text":"<ul> <li>bugfix: computed field returning a composite type was always null</li> </ul>"},{"location":"changelog/#154","title":"1.5.4","text":"<ul> <li>bugfix: once a query panics, all subsequent queries return a lock poisoned error.</li> </ul>"},{"location":"changelog/#156","title":"1.5.6","text":"<ul> <li>feature: add support for filtering on array column types using <code>contains</code>, <code>containedBy</code>, <code>overlaps</code>, <code>is</code>, <code>eq</code></li> </ul>"},{"location":"changelog/#157","title":"1.5.7","text":"<ul> <li>bugfix: UDF argument with a complex default expression was marked as required</li> <li>bugfix: not null foreign keys referencing tables with RLS are marked as nullable</li> </ul>"},{"location":"changelog/#158","title":"1.5.8","text":"<ul> <li>bugfix: relational query with more than 100 fields fails</li> </ul>"},{"location":"changelog/#master","title":"master","text":""},{"location":"computed_fields/","title":"Computed Fields","text":""},{"location":"computed_fields/#computed-values","title":"Computed Values","text":""},{"location":"computed_fields/#postgresql-builtin-preferred","title":"PostgreSQL Builtin (Preferred)","text":"<p>PostgreSQL has a builtin method for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the recommended approach to adding computed fields when your computation meets the restrictions. Namely:</p> <ul> <li>expression must be immutable</li> <li>expression may only reference the current row</li> </ul> <p>For example: <pre><code>begin;\n    comment on schema public is '@graphql({\"inflect_names\": true})';\n    create table public.account(\n        id serial primary key,\n        first_name varchar(255) not null,\n        last_name varchar(255) not null,\n        -- Computed Column\n        full_name text generated always as (first_name || ' ' ||  last_name) stored\n    );\n    insert into public.account(first_name, last_name)\n    values\n        ('Foo', 'Fooington');\n    select jsonb_pretty(\n        graphql.resolve($$\n    {\n      accountCollection {\n        edges {\n          node {\n            id\n            firstName\n            lastName\n            fullName\n          }\n        }\n      }\n    }\n        $$)\n    );\n                     jsonb_pretty                     \n------------------------------------------------------\n {                                                   +\n     \"data\": {                                       +\n         \"accountCollection\": {                      +\n             \"edges\": [                              +\n                 {                                   +\n                     \"node\": {                       +\n                         \"id\": 1,                    +\n                         \"fullName\": \"Foo Fooington\",+\n                         \"lastName\": \"Fooington\",    +\n                         \"firstName\": \"Foo\"          +\n                     }                               +\n                 }                                   +\n             ]                                       +\n         }                                           +\n     }                                               +\n }\n(1 row)\n\nrollback;\n</code></pre></p>"},{"location":"computed_fields/#extending-types-with-functions","title":"Extending Types with Functions","text":"<p>For arbitrary computations that do not meet the requirements for generated columns, a table's reflected GraphQL type can be extended by creating a function that:</p> <ul> <li>accepts a single argument of the table's tuple type</li> </ul> <pre><code>begin;\n    comment on schema public is '@graphql({\"inflect_names\": true})';\n    create table public.account(\n        id serial primary key,\n        first_name varchar(255) not null,\n        last_name varchar(255) not null,\n        parent_id int references account(id)\n    );\n    -- Extend with function\n    create function public._full_name(rec public.account)\n        returns text\n        immutable\n        strict\n        language sql\n    as $$\n        select format('%s %s', rec.first_name, rec.last_name)\n    $$;\n    insert into public.account(first_name, last_name, parent_id)\n    values\n        ('Foo', 'Fooington', 1);\n    select jsonb_pretty(\n        graphql.resolve($$\n    {\n      accountCollection {\n        edges {\n          node {\n            id\n            firstName\n            lastName\n            fullName\n            parent {\n              fullName\n            }\n          }\n        }\n      }\n    }\n        $$)\n    );\n                      jsonb_pretty                       \n---------------------------------------------------------\n {                                                      +\n     \"data\": {                                          +\n         \"accountCollection\": {                         +\n             \"edges\": [                                 +\n                 {                                      +\n                     \"node\": {                          +\n                         \"id\": 1,                       +\n                         \"parent\": {                    +\n                             \"fullName\": \"Foo Fooington\"+\n                         },                             +\n                         \"fullName\": \"Foo Fooington\",   +\n                         \"lastName\": \"Fooington\",       +\n                         \"firstName\": \"Foo\"             +\n                     }                                  +\n                 }                                      +\n             ]                                          +\n         }                                              +\n     }                                                  +\n }\n(1 row)\n\nrollback;\n</code></pre> <p>If the function is written in SQL, its volatility can impact freshness of data returned in mutations:</p> <pre><code>begin;\n-- A computed field function written in SQL and marked stable might return stale results.\n-- Directly from the postgres docs(https://www.postgresql.org/docs/current/xfunc-volatility.html):\n--For functions written in SQL or in any of the standard procedural languages,\n--there is a second important property determined by the volatility category,\n--namely the visibility of any data changes that have been made by the SQL\n--command that is calling the function. A VOLATILE function will see such\n--changes, a STABLE or IMMUTABLE function will not. This behavior is\n--implemented using the snapshotting behavior of MVCC (see Chapter 13): STABLE\n--and IMMUTABLE functions use a snapshot established as of the start of the\n--calling query, whereas VOLATILE functions obtain a fresh snapshot at the\n--start of each query they execute.\n--The solution is to mark these functions as volatile\ncreate table parent\n(\n    id uuid primary key default gen_random_uuid(),\n    count int2\n);\ncreate table child\n(\n    id uuid primary key default gen_random_uuid(),\n    parent_id uuid references parent not null,\n    count int2\n);\n-- note that the function is marked stable and in written in sql\ncreate or replace function _count(rec parent)\n    returns smallint\n    stable\n    language sql\nas\n$$\n    select sum(count)\n    from child\n    where parent_id = rec.id\n$$;\ninsert into parent (id, count)\nvalues ('8bcf0ee4-95ed-445f-808f-17b8194727ca', 1);\ninsert into child (id, parent_id, count)\nvalues ('57738181-3d0f-45ad-96dd-3ba799b2d21d', '8bcf0ee4-95ed-445f-808f-17b8194727ca', 2),\n       ('cb5993ff-e693-49cd-9114-a6510707e628', '8bcf0ee4-95ed-445f-808f-17b8194727ca', 3);\nselect jsonb_pretty(\n  graphql.resolve($$\n    query ParentQuery {\n      parentCollection {\n        edges {\n          node {\n            id\n            count\n            childCollection {\n              edges {\n                node {\n                  count\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  $$)\n);\n                             jsonb_pretty                              \n-----------------------------------------------------------------------\n {                                                                    +\n     \"data\": {                                                        +\n         \"parentCollection\": {                                        +\n             \"edges\": [                                               +\n                 {                                                    +\n                     \"node\": {                                        +\n                         \"id\": \"8bcf0ee4-95ed-445f-808f-17b8194727ca\",+\n                         \"count\": 5,                                  +\n                         \"childCollection\": {                         +\n                             \"edges\": [                               +\n                                 {                                    +\n                                     \"node\": {                        +\n                                         \"count\": 2                   +\n                                     }                                +\n                                 },                                   +\n                                 {                                    +\n                                     \"node\": {                        +\n                                         \"count\": 3                   +\n                                     }                                +\n                                 }                                    +\n                             ]                                        +\n                         }                                            +\n                     }                                                +\n                 }                                                    +\n             ]                                                        +\n         }                                                            +\n     }                                                                +\n }\n(1 row)\n\n-- since _count is stable, the value returned in parent.count field will be stale\n-- i.e. parent.count is still 5 instead of (3 + 5) = 8\nselect jsonb_pretty(\n  graphql.resolve($$\n    mutation ChildMutation {\n      updateChildCollection(\n        filter: { id: { eq: \"57738181-3d0f-45ad-96dd-3ba799b2d21d\" } }\n        set: { count: 5 }\n      ) {\n        records {\n          id\n          count\n          parent {\n            id\n            count\n          }\n        }\n      }\n    }\n  $$)\n);\n                             jsonb_pretty                              \n-----------------------------------------------------------------------\n {                                                                    +\n     \"data\": {                                                        +\n         \"updateChildCollection\": {                                   +\n             \"records\": [                                             +\n                 {                                                    +\n                     \"id\": \"57738181-3d0f-45ad-96dd-3ba799b2d21d\",    +\n                     \"count\": 5,                                      +\n                     \"parent\": {                                      +\n                         \"id\": \"8bcf0ee4-95ed-445f-808f-17b8194727ca\",+\n                         \"count\": 5                                   +\n                     }                                                +\n                 }                                                    +\n             ]                                                        +\n         }                                                            +\n     }                                                                +\n }\n(1 row)\n\n-- note that the function is marked volatile\ncreate or replace function _count(rec parent)\n    returns smallint\n    volatile\n    language sql\nas\n$$\n    select sum(count)\n    from child\n    where parent_id = rec.id\n$$;\n-- since _count is volatile, the value returned in parent.count field will be fresh\n-- i.e. parent.count is correctly at (3 + 7) 10\nselect jsonb_pretty(\n  graphql.resolve($$\n    mutation ChildMutation {\n      updateChildCollection(\n        filter: { id: { eq: \"57738181-3d0f-45ad-96dd-3ba799b2d21d\" } }\n        set: { count: 7 }\n      ) {\n        records {\n          id\n          count\n          parent {\n            id\n            count\n          }\n        }\n      }\n    }\n  $$)\n);\n                             jsonb_pretty                              \n-----------------------------------------------------------------------\n {                                                                    +\n     \"data\": {                                                        +\n         \"updateChildCollection\": {                                   +\n             \"records\": [                                             +\n                 {                                                    +\n                     \"id\": \"57738181-3d0f-45ad-96dd-3ba799b2d21d\",    +\n                     \"count\": 7,                                      +\n                     \"parent\": {                                      +\n                         \"id\": \"8bcf0ee4-95ed-445f-808f-17b8194727ca\",+\n                         \"count\": 10                                  +\n                     }                                                +\n                 }                                                    +\n             ]                                                        +\n         }                                                            +\n     }                                                                +\n }\n(1 row)\n\nrollback;\n</code></pre>"},{"location":"computed_fields/#computed-relationships","title":"Computed Relationships","text":"<p>Computed relations can be helpful to express relationships:</p> <ul> <li>between entities that don't support foreign keys</li> <li>too complex to be expressed via a foreign key</li> </ul> <p>If the relationship is simple, but involves an entity that does not support foreign keys e.g. Foreign Data Wrappers / Views, defining a comment directive is the easiest solution. See the view doc for a complete example. Note that for entities that do not support a primary key, like views, you must define one using a comment directive to use them in a computed relationship.</p> <p>Alternatively, if the relationship is complex, or you need compatibility with PostgREST, you can define a relationship using set returning functions.</p>"},{"location":"computed_fields/#to-one","title":"To-One","text":"<p>To One relationships can be defined using a function that returns <code>setof &lt;entity&gt; rows 1</code></p> <p>For example <pre><code>create table \"Person\" (\n    id int primary key,\n    name text\n);\n\ncreate table \"Address\"(\n    id int primary key,\n    \"isPrimary\" bool not null default false,\n    \"personId\" int references \"Person\"(id),\n    address text\n);\n\n-- Example computed relation\ncreate function \"primaryAddress\"(\"Person\")\n    returns setof \"Address\" rows 1\n    language sql\n    as\n$$\n    select addr\n    from \"Address\" addr\n    where $1.id = addr.\"personId\"\n          and addr.\"isPrimary\"\n    limit 1\n$$;\n\ninsert into \"Person\"(id, name)\nvalues (1, 'Foo Barington');\n\ninsert into \"Address\"(id, \"isPrimary\", \"personId\", address)\nvalues (4, true, 1, '1 Main St.');\n</code></pre></p> <p>results in the GraphQL type</p> Person <pre><code>type Person implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  ...\n  primaryAddress: Address\n}\n</code></pre> <p>and can be queried like a natively enforced relationship</p> QueryResponse <pre><code>{\n  personCollection {\n    edges {\n      node {\n        id\n        name\n        primaryAddress {\n          address\n        }\n      }\n    }\n\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"personCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"Foo Barington\",\n            \"primaryAddress\": {\n              \"address\": \"1 Main St.\"\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"computed_fields/#to-many","title":"To-Many","text":"<p>To-many relationships can be defined using a function that returns a <code>setof &lt;entity&gt;</code></p> <p>For example: <pre><code>create table \"Person\" (\n    id int primary key,\n    name text\n);\n\ncreate table \"Address\"(\n    id int primary key,\n    address text\n);\n\ncreate table \"PersonAtAddress\"(\n    id int primary key,\n    \"personId\" int not null,\n    \"addressId\" int not null\n);\n\n\n-- Computed relation to bypass \"PersonAtAddress\" table for cleaner API\ncreate function \"addresses\"(\"Person\")\n    returns setof \"Address\"\n    language sql\n    as\n$$\n    select\n        addr\n    from\n        \"PersonAtAddress\" pa\n        join \"Address\" addr\n            on pa.\"addressId\" = \"addr\".id\n    where\n        pa.\"personId\" = $1.id\n$$;\n\ninsert into \"Person\"(id, name)\nvalues (1, 'Foo Barington');\n\ninsert into \"Address\"(id, address)\nvalues (4, '1 Main St.');\n\ninsert into \"PersonAtAddress\"(id, \"personId\", \"addressId\")\nvalues (2, 1, 4);\n</code></pre></p> <p>results in the GraphQL type</p> Person <pre><code>type Person implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  ...\n  addresses(\n    first: Int\n    last: Int\n    before: Cursor\n    after: Cursor\n    filter: AddressFilter\n    orderBy: [AddressOrderBy!]\n  ): AddressConnection\n}\n</code></pre> <p>and can be queried like a natively enforced relationship</p> QueryResponse <pre><code>{\n  personCollection {\n    edges {\n      node {\n        id\n        name\n        addresses {\n          edges {\n            node {\n              id\n              address\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"personCollection\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"name\": \"Foo Barington\",\n            \"addresses\": {\n              \"edges\": [\n                {\n                  \"node\": {\n                    \"id\": 4,\n                    \"address\": \"1 Main St.\"\n                  }\n                }\n              ]\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>Extra configuration options can be set on SQL entities using comment directives.</p>"},{"location":"configuration/#comment-directives","title":"Comment Directives","text":"<p>Comment directives are snippets of configuration associated with SQL entities that alter how those entities behave.</p> <p>The format of a comment directive is</p> <pre><code>@graphql(&lt;JSON&gt;)\n</code></pre>"},{"location":"configuration/#inflection","title":"Inflection","text":"<p>Inflection describes how SQL entities' names are transformed into GraphQL type and field names. By default, inflection is disabled and SQL names are literally interpolated such that</p> <pre><code>create table \"BlogPost\"(\n    id int primary key,\n    ...\n);\n</code></pre> <p>results in GraphQL type names like <pre><code>BlogPost\nBlogPostEdge\nBlogPostConnection\n...\n</code></pre></p> <p>Since snake case is a common casing structure for SQL types, <code>pg_graphql</code> support basic inflection from <code>snake_case</code> to <code>PascalCase</code> for type names, and <code>snake_case</code> to <code>camelCase</code> for field names to match Javascript conventions.</p> <p>The inflection directive can be applied at the schema level with:</p> <pre><code>comment on schema &lt;schema_name&gt; is e'@graphql({\"inflect_names\": true})';\n</code></pre> <p>for example <pre><code>comment on schema public is e'@graphql({\"inflect_names\": true})';\n\ncreate table blog_post(\n    id int primary key,\n    ...\n);\n</code></pre></p> <p>similarly would generated the GraphQL type names <pre><code>BlogPost\nBlogPostEdge\nBlogPostConnection\n...\n</code></pre></p> <p>For more fine grained adjustments to reflected names, see renaming.</p>"},{"location":"configuration/#max-rows","title":"Max Rows","text":"<p>The default page size for collections is 30 entries. To adjust the number of entries on each page, set a <code>max_rows</code> directive on the relevant schema entity.</p> <p>For example, to increase the max rows per page for each table in the <code>public</code> schema: <pre><code>comment on schema public is e'@graphql({\"max_rows\": 100})';\n</code></pre></p>"},{"location":"configuration/#totalcount","title":"totalCount","text":"<p><code>totalCount</code> is an opt-in field that extends a table's Connection type. It provides a count of the rows that match the query's filters, and ignores pagination arguments.</p> <pre><code>type BlogPostConnection {\n  edges: [BlogPostEdge!]!\n  pageInfo: PageInfo!\n\n  \"\"\"The total number of records matching the `filter` criteria\"\"\"\n  totalCount: Int! # this field\n}\n</code></pre> <p>to enable <code>totalCount</code> for a table, use the directive</p> <p><pre><code>comment on table \"BlogPost\" is e'@graphql({\"totalCount\": {\"enabled\": true}})';\n</code></pre> for example <pre><code>create table \"BlogPost\"(\n    id serial primary key,\n    email varchar(255) not null\n);\ncomment on table \"BlogPost\" is e'@graphql({\"totalCount\": {\"enabled\": true}})';\n</code></pre></p>"},{"location":"configuration/#renaming","title":"Renaming","text":""},{"location":"configuration/#tables-type","title":"Table's Type","text":"<p>Use the <code>\"name\"</code> JSON key to override a table's type name.</p> <pre><code>create table account(\n    id serial primary key\n);\n\ncomment on table public.account is\ne'@graphql({\"name\": \"AccountHolder\"})';\n</code></pre> <p>results in: <pre><code>type AccountHolder { # previously: \"Account\"\n  id: Int!\n}\n</code></pre></p>"},{"location":"configuration/#columns-field-name","title":"Column's Field Name","text":"<p>Use the <code>\"name\"</code> JSON key to override a column's field name.</p> <pre><code>create table public.\"Account\"(\n    id serial primary key,\n    email text\n);\n\ncomment on column \"Account\".email is\ne'@graphql({\"name\": \"emailAddress\"})';\n</code></pre> <p>results in: <pre><code>type Account {\n  nodeId: ID!\n  id: Int!\n  emailAddress: String! # previously \"email\"\n}\n</code></pre></p>"},{"location":"configuration/#computed-field","title":"Computed Field","text":"<p>Use the <code>\"name\"</code> JSON key to override a computed field's name.</p> <pre><code>create table \"Account\"(\n    id serial primary key,\n    \"firstName\" varchar(255) not null,\n    \"lastName\" varchar(255) not null\n);\n\n-- Extend with function\ncreate function public.\"_fullName\"(rec public.\"Account\")\n    returns text\n    immutable\n    strict\n    language sql\nas $$\n    select format('%s %s', rec.\"firstName\", rec.\"lastName\")\n$$;\n\ncomment on function public._full_name is\ne'@graphql({\"name\": \"displayName\"})';\n</code></pre> <p>results in: <pre><code>type Account {\n  nodeId: ID!\n  id: Int!\n  firstName: String!\n  lastName: String!\n  displayName: String # previously \"fullName\"\n}\n</code></pre></p>"},{"location":"configuration/#relationships-field","title":"Relationship's Field","text":"<p>Use the <code>\"local_name\"</code> and <code>\"foreign_name\"</code> JSON keys to override a relationship's inbound and outbound field names.</p> <pre><code>create table \"Account\"(\n    id serial primary key\n);\n\ncreate table \"Post\"(\n    id serial primary key,\n    \"accountId\" integer not null references \"Account\"(id),\n    title text not null,\n    body text\n);\n\ncomment on constraint post_owner_id_fkey\n  on \"Post\"\n  is E'@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})';\n</code></pre> <p>results in: <pre><code>type Post {\n  nodeId: ID!\n  id: Int!\n  accountId: Int!\n  title: String!\n  body: String!\n  author: Account # was \"account\"\n}\n\ntype Account {\n  id: Int!\n  posts( # was \"postCollection\"\n    after: Cursor,\n    before: Cursor,\n    filter: PostFilter,\n    first: Int,\n    last: Int,\n    orderBy: [PostOrderBy!]\n  ): PostConnection\n}\n</code></pre></p>"},{"location":"configuration/#description","title":"Description","text":"<p>Tables, Columns, and Functions accept a <code>description</code> directive to populate user defined descriptions in the GraphQL schema.</p> <pre><code>create table \"Account\"(\n    id serial primary key\n);\n\ncomment on table public.account\nis e'@graphql({\"description\": \"A User Account\"})';\n\ncomment on column public.account.id\nis e'@graphql({\"description\": \"The primary key identifier\"})';\n</code></pre> <pre><code>\"\"\"A User Account\"\"\"\ntype Account implements Node {\n\n  \"\"\"The primary key identifier\"\"\"\n  id: Int!\n}\n</code></pre>"},{"location":"configuration/#enum-variant","title":"Enum Variant","text":"<p>If a variant of a Postgres enum does not conform to GraphQL naming conventions, introspection returns an error:</p> <p>For example: <pre><code>create type \"Algorithm\" as enum ('aead-ietf');\n</code></pre></p> <p>causes the error:</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\": \"Names must only contain [_a-zA-Z0-9] but \\\"aead-ietf\\\" does not.\",\n    }\n  ]\n}\n</code></pre> <p>To resolve this problem, rename the invalid SQL enum variant to a GraphQL compatible name:</p> <pre><code>alter type \"Algorithm\" rename value 'aead-ietf' to 'AEAD_IETF';\n</code></pre> <p>or, add a comment directive to remap the enum variant in the GraphQL API</p> <pre><code>comment on type \"Algorithm\" is '@graphql({\"mappings\": {\"aead-ietf\": \"AEAD_IETF\"}})';\n</code></pre> <p>Which both result in the GraphQL enum: <pre><code>enum Algorithm {\n  AEAD_IETF\n}\n</code></pre></p>"},{"location":"contributing/","title":"Contributing","text":"<p>pg_graphql is OSS. PR and issues are welcome.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>To start developing <code>pg_graphql</code>:</p> <ol> <li>Install Rust.</li> <li>Install pgrx</li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Tests are located in sql files in the <code>./test/sql</code> folder. Each sql file has a corresponding expected output file in <code>./test/expected</code> folder. For example, <code>./test/sql/aliases.sql</code>'s expected output is in <code>./tests/expected/aliases.out</code>. When a test runs, its actual output is saved in the <code>./results</code> folder. If the file in <code>./results</code> folder matches the corresponding file in the <code>./test/expected</code> folder, the test passes, otherwise it fails.</p> <p>To run tests locally, first execute:</p> <pre><code>cargo pgrx install\n</code></pre> <p>to build <code>pg_graphql</code> from source and install it in the Postgres instance specified by <code>pg_config</code>. This step must be run when you have made any changes in the Rust code. It can be skipped if there are no Rust code changes since the last time the command was run. The skipping is expecially useful when you are only modifying the test sql files.</p> <p>Next, run all the tests by executing:</p> <pre><code>./bin/installcheck\n</code></pre> <p>You can combine the last two steps to build and install <code>pg_graphql</code> and run all the tests:</p> <pre><code>$ cargo pgrx install; ./bin/installcheck\n</code></pre> <p>You can run a single test by passing its name to the <code>installcheck</code> command. For example, the following runs the test in <code>./test/sql/aliases.sql</code>.</p> <pre><code>./bin/installcheck aliases\n</code></pre> <p>When writing a new test, or editing an existing one, the file in <code>./result</code> should be inspected manually and then copied over to the <code>./test/expected</code> folder to make the test pass.</p>"},{"location":"contributing/#debugging","title":"Debugging","text":"<p>You can print to the output by using the <code>pgrx_pg_sys::submodules::elog::info!</code> macro in the Rust code. Lines printed with this macro will show in the .out file in the <code>./results</code> folder.</p>"},{"location":"contributing/#interactive-psql-development","title":"Interactive PSQL Development","text":"<p>To reduce the iteration cycle, you may want to launch a psql prompt with <code>pg_graphql</code> installed to experiment</p> <pre><code>cargo pgrx run pg16\n</code></pre> <p>Try out the commands below to spin up a database with the extension installed &amp; query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns.</p> <pre><code>graphqldb= create extension pg_graphql cascade;\nCREATE EXTENSION\n\ngraphqldb= create table book(id int primary key, title text);\nCREATE TABLE\n\ngraphqldb= insert into book(id, title) values (1, 'book 1');\nINSERT 0 1\n</code></pre> <p>Finally, execute some graphql queries against the table. <pre><code>graphqldb= select graphql.resolve($$\nquery {\n  bookCollection {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n$$);\n\n             resolve\n----------------------------------------------------------------------\n{\"data\": {\"bookCollection\": {\"edges\": [{\"node\": {\"id\": 1}}]}}, \"errors\": []}\n</code></pre></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>All public API must be documented. Building documentation requires python 3.6+</p>"},{"location":"contributing/#install-dependencies","title":"Install Dependencies","text":"<p>Install mkdocs, themes, and extensions.</p> <pre><code>pip install -r docs/requirements_docs.txt\n</code></pre>"},{"location":"contributing/#serving","title":"Serving","text":"<p>To serve the documentation locally run</p> <pre><code>mkdocs serve\n</code></pre> <p>and visit the docs at http://127.0.0.1:8000/pg_graphql/</p>"},{"location":"example_schema/","title":"Example Schema","text":"<p>The following is a complete example showing how a sample SQL schema translates into a GraphQL schema.</p> <pre><code>-- Turn on automatic inflection of type names\ncomment on schema public is '@graphql({\"inflect_names\": true})';\n\ncreate table account(\n    id serial primary key,\n    email varchar(255) not null,\n    created_at timestamp not null,\n    updated_at timestamp not null\n);\n\n-- enable a `totalCount` field on the `account` query type\ncomment on table account is e'@graphql({\"totalCount\": {\"enabled\": true}})';\n\ncreate table blog(\n    id serial primary key,\n    owner_id integer not null references account(id),\n    name varchar(255) not null,\n    description varchar(255),\n    tags text[],\n    created_at timestamp not null,\n    updated_at timestamp not null\n);\n\ncreate type blog_post_status as enum ('PENDING', 'RELEASED');\n\ncreate table blog_post(\n    id uuid not null default gen_random_uuid() primary key,\n    blog_id integer not null references blog(id),\n    title varchar(255) not null,\n    body varchar(10000),\n    status blog_post_status not null,\n    created_at timestamp not null,\n    updated_at timestamp not null\n);\n</code></pre> <pre><code>type Account implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  id: Int!\n  email: String!\n  createdAt: Datetime!\n  updatedAt: Datetime!\n  blogCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"\n    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.\n    \"\"\"\n    offset: Int\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n  ): BlogConnection\n}\n\ntype AccountConnection {\n  edges: [AccountEdge!]!\n  pageInfo: PageInfo!\n\n  \"\"\"The total number of records matching the `filter` criteria\"\"\"\n  totalCount: Int!\n}\n\ntype AccountDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Account!]!\n}\n\ntype AccountEdge {\n  cursor: String!\n  node: Account!\n}\n\ninput AccountFilter {\n  id: IntFilter\n  email: StringFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  nodeId: IDFilter\n\n  \"\"\"\n  Returns true only if all its inner filters are true, otherwise returns false\n  \"\"\"\n  and: [AccountFilter!]\n\n  \"\"\"\n  Returns true if at least one of its inner filters is true, otherwise returns false\n  \"\"\"\n  or: [AccountFilter!]\n\n  \"\"\"Negates a filter\"\"\"\n  not: AccountFilter\n}\n\ninput AccountInsertInput {\n  email: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n\ntype AccountInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Account!]!\n}\n\ninput AccountOrderBy {\n  id: OrderByDirection\n  email: OrderByDirection\n  createdAt: OrderByDirection\n  updatedAt: OrderByDirection\n}\n\ninput AccountUpdateInput {\n  email: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n\ntype AccountUpdateResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Account!]!\n}\n\n\"\"\"A high precision floating point value represented as a string\"\"\"\nscalar BigFloat\n\n\"\"\"\nBoolean expression comparing fields on type \"BigFloat\"\n\"\"\"\ninput BigFloatFilter {\n  eq: BigFloat\n  gt: BigFloat\n  gte: BigFloat\n  in: [BigFloat!]\n  is: FilterIs\n  lt: BigFloat\n  lte: BigFloat\n  neq: BigFloat\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"BigFloatList\"\n\"\"\"\ninput BigFloatListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\n\"\"\"An arbitrary size integer represented as a string\"\"\"\nscalar BigInt\n\n\"\"\"\nBoolean expression comparing fields on type \"BigInt\"\n\"\"\"\ninput BigIntFilter {\n  eq: BigInt\n  gt: BigInt\n  gte: BigInt\n  in: [BigInt!]\n  is: FilterIs\n  lt: BigInt\n  lte: BigInt\n  neq: BigInt\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"BigIntList\"\n\"\"\"\ninput BigIntListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\ntype Blog implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  id: Int!\n  ownerId: Int!\n  name: String!\n  description: String\n  tags: [String]\n  createdAt: Datetime!\n  updatedAt: Datetime!\n  owner: Account!\n  blogPostCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"\n    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.\n    \"\"\"\n    offset: Int\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogPostOrderBy!]\n  ): BlogPostConnection\n}\n\ntype BlogConnection {\n  edges: [BlogEdge!]!\n  pageInfo: PageInfo!\n}\n\ntype BlogDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n\ntype BlogEdge {\n  cursor: String!\n  node: Blog!\n}\n\ninput BlogFilter {\n  id: IntFilter\n  ownerId: IntFilter\n  name: StringFilter\n  description: StringFilter\n  tags: StringListFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  nodeId: IDFilter\n\n  \"\"\"\n  Returns true only if all its inner filters are true, otherwise returns false\n  \"\"\"\n  and: [BlogFilter!]\n\n  \"\"\"\n  Returns true if at least one of its inner filters is true, otherwise returns false\n  \"\"\"\n  or: [BlogFilter!]\n\n  \"\"\"Negates a filter\"\"\"\n  not: BlogFilter\n}\n\ninput BlogInsertInput {\n  ownerId: Int\n  name: String\n  description: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n\ntype BlogInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n\ninput BlogOrderBy {\n  id: OrderByDirection\n  ownerId: OrderByDirection\n  name: OrderByDirection\n  description: OrderByDirection\n  createdAt: OrderByDirection\n  updatedAt: OrderByDirection\n}\n\ntype BlogPost implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  id: UUID!\n  blogId: Int!\n  title: String!\n  body: String\n  status: BlogPostStatus!\n  createdAt: Datetime!\n  updatedAt: Datetime!\n  blog: Blog!\n}\n\ntype BlogPostConnection {\n  edges: [BlogPostEdge!]!\n  pageInfo: PageInfo!\n}\n\ntype BlogPostDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [BlogPost!]!\n}\n\ntype BlogPostEdge {\n  cursor: String!\n  node: BlogPost!\n}\n\ninput BlogPostFilter {\n  id: UUIDFilter\n  blogId: IntFilter\n  title: StringFilter\n  body: StringFilter\n  status: BlogPostStatusFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  nodeId: IDFilter\n\n  \"\"\"\n  Returns true only if all its inner filters are true, otherwise returns false\n  \"\"\"\n  and: [BlogPostFilter!]\n\n  \"\"\"\n  Returns true if at least one of its inner filters is true, otherwise returns false\n  \"\"\"\n  or: [BlogPostFilter!]\n\n  \"\"\"Negates a filter\"\"\"\n  not: BlogPostFilter\n}\n\ninput BlogPostInsertInput {\n  id: UUID\n  blogId: Int\n  title: String\n  body: String\n  status: BlogPostStatus\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n\ntype BlogPostInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [BlogPost!]!\n}\n\ninput BlogPostOrderBy {\n  id: OrderByDirection\n  blogId: OrderByDirection\n  title: OrderByDirection\n  body: OrderByDirection\n  status: OrderByDirection\n  createdAt: OrderByDirection\n  updatedAt: OrderByDirection\n}\n\nenum BlogPostStatus {\n  PENDING\n  RELEASED\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"BlogPostStatus\"\n\"\"\"\ninput BlogPostStatusFilter {\n  eq: BlogPostStatus\n  in: [BlogPostStatus!]\n  is: FilterIs\n  neq: BlogPostStatus\n}\n\ninput BlogPostUpdateInput {\n  id: UUID\n  blogId: Int\n  title: String\n  body: String\n  status: BlogPostStatus\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n\ntype BlogPostUpdateResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [BlogPost!]!\n}\n\ninput BlogUpdateInput {\n  ownerId: Int\n  name: String\n  description: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n\ntype BlogUpdateResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"Boolean\"\n\"\"\"\ninput BooleanFilter {\n  eq: Boolean\n  is: FilterIs\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"BooleanList\"\n\"\"\"\ninput BooleanListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\n\"\"\"\nAn opaque string using for tracking a position in results during pagination\n\"\"\"\nscalar Cursor\n\n\"\"\"A date without time information\"\"\"\nscalar Date\n\n\"\"\"\nBoolean expression comparing fields on type \"Date\"\n\"\"\"\ninput DateFilter {\n  eq: Date\n  gt: Date\n  gte: Date\n  in: [Date!]\n  is: FilterIs\n  lt: Date\n  lte: Date\n  neq: Date\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"DateList\"\n\"\"\"\ninput DateListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\n\"\"\"A date and time\"\"\"\nscalar Datetime\n\n\"\"\"\nBoolean expression comparing fields on type \"Datetime\"\n\"\"\"\ninput DatetimeFilter {\n  eq: Datetime\n  gt: Datetime\n  gte: Datetime\n  in: [Datetime!]\n  is: FilterIs\n  lt: Datetime\n  lte: Datetime\n  neq: Datetime\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"DatetimeList\"\n\"\"\"\ninput DatetimeListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\nenum FilterIs {\n  NULL\n  NOT_NULL\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"Float\"\n\"\"\"\ninput FloatFilter {\n  eq: Float\n  gt: Float\n  gte: Float\n  in: [Float!]\n  is: FilterIs\n  lt: Float\n  lte: Float\n  neq: Float\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"FloatList\"\n\"\"\"\ninput FloatListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"ID\"\n\"\"\"\ninput IDFilter {\n  eq: ID\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"Int\"\n\"\"\"\ninput IntFilter {\n  eq: Int\n  gt: Int\n  gte: Int\n  in: [Int!]\n  is: FilterIs\n  lt: Int\n  lte: Int\n  neq: Int\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"IntList\"\n\"\"\"\ninput IntListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\n\"\"\"A Javascript Object Notation value serialized as a string\"\"\"\nscalar JSON\n\n\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n  \"\"\"Deletes zero or more records from the `Account` collection\"\"\"\n  deleteFromAccountCollection(\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: AccountFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): AccountDeleteResponse!\n\n  \"\"\"Deletes zero or more records from the `Blog` collection\"\"\"\n  deleteFromBlogCollection(\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogDeleteResponse!\n\n  \"\"\"Deletes zero or more records from the `BlogPost` collection\"\"\"\n  deleteFromBlogPostCollection(\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogPostDeleteResponse!\n\n  \"\"\"Adds one or more `Account` records to the collection\"\"\"\n  insertIntoAccountCollection(objects: [AccountInsertInput!]!): AccountInsertResponse\n\n  \"\"\"Adds one or more `Blog` records to the collection\"\"\"\n  insertIntoBlogCollection(objects: [BlogInsertInput!]!): BlogInsertResponse\n\n  \"\"\"Adds one or more `BlogPost` records to the collection\"\"\"\n  insertIntoBlogPostCollection(objects: [BlogPostInsertInput!]!): BlogPostInsertResponse\n\n  \"\"\"Updates zero or more records in the `Account` collection\"\"\"\n  updateAccountCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: AccountUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: AccountFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): AccountUpdateResponse!\n\n  \"\"\"Updates zero or more records in the `Blog` collection\"\"\"\n  updateBlogCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogUpdateResponse!\n\n  \"\"\"Updates zero or more records in the `BlogPost` collection\"\"\"\n  updateBlogPostCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogPostUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogPostUpdateResponse!\n}\n\ninterface Node {\n  \"\"\"Retrieves a record by `ID`\"\"\"\n  nodeId: ID!\n}\n\n\"\"\"Any type not handled by the type system\"\"\"\nscalar Opaque\n\n\"\"\"\nBoolean expression comparing fields on type \"Opaque\"\n\"\"\"\ninput OpaqueFilter {\n  eq: Opaque\n  is: FilterIs\n}\n\n\"\"\"Defines a per-field sorting order\"\"\"\nenum OrderByDirection {\n  \"\"\"Ascending order, nulls first\"\"\"\n  AscNullsFirst\n\n  \"\"\"Ascending order, nulls last\"\"\"\n  AscNullsLast\n\n  \"\"\"Descending order, nulls first\"\"\"\n  DescNullsFirst\n\n  \"\"\"Descending order, nulls last\"\"\"\n  DescNullsLast\n}\n\ntype PageInfo {\n  endCursor: String\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n}\n\n\"\"\"The root type for querying data\"\"\"\ntype Query {\n  \"\"\"A pagable collection of type `Account`\"\"\"\n  accountCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"\n    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.\n    \"\"\"\n    offset: Int\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: AccountFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [AccountOrderBy!]\n  ): AccountConnection\n\n  \"\"\"A pagable collection of type `Blog`\"\"\"\n  blogCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"\n    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.\n    \"\"\"\n    offset: Int\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n  ): BlogConnection\n\n  \"\"\"A pagable collection of type `BlogPost`\"\"\"\n  blogPostCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"\n    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.\n    \"\"\"\n    offset: Int\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogPostOrderBy!]\n  ): BlogPostConnection\n\n  \"\"\"Retrieve a record by its `ID`\"\"\"\n  node(\n    \"\"\"The record's `ID`\"\"\"\n    nodeId: ID!\n  ): Node\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"String\"\n\"\"\"\ninput StringFilter {\n  eq: String\n  gt: String\n  gte: String\n  ilike: String\n  in: [String!]\n  iregex: String\n  is: FilterIs\n  like: String\n  lt: String\n  lte: String\n  neq: String\n  regex: String\n  startsWith: String\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"StringList\"\n\"\"\"\ninput StringListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\n\"\"\"A time without date information\"\"\"\nscalar Time\n\n\"\"\"\nBoolean expression comparing fields on type \"Time\"\n\"\"\"\ninput TimeFilter {\n  eq: Time\n  gt: Time\n  gte: Time\n  in: [Time!]\n  is: FilterIs\n  lt: Time\n  lte: Time\n  neq: Time\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"TimeList\"\n\"\"\"\ninput TimeListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n\n\"\"\"A universally unique identifier\"\"\"\nscalar UUID\n\n\"\"\"\nBoolean expression comparing fields on type \"UUID\"\n\"\"\"\ninput UUIDFilter {\n  eq: UUID\n  in: [UUID!]\n  is: FilterIs\n  neq: UUID\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"UUIDList\"\n\"\"\"\ninput UUIDListFilter {\n  containedBy: [BigFloat!]\n  contains: [BigFloat!]\n  eq: [BigFloat!]\n  overlaps: [BigFloat!]\n  is: FilterIs\n}\n</code></pre>"},{"location":"functions/","title":"Functions","text":"<p>Functions can be exposed by pg_graphql to allow running custom queries or mutations.</p>"},{"location":"functions/#query-vs-mutation","title":"Query vs Mutation","text":"<p>For example, a function to add two numbers will be available on the query type as a field:</p> FunctionQueryTypeQueryResponse <pre><code>create function \"addNums\"(a int, b int)\n  returns int\n  immutable\n  language sql\nas $$ select a + b; $$;\n</code></pre> <pre><code>type Query {\n  addNums(a: Int!, b: Int!): Int\n}\n</code></pre> <pre><code>query {\n  addNums(a: 2, b: 3)\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"addNums\": 5\n  }\n}\n</code></pre> <p>Functions marked <code>immutable</code> or <code>stable</code> are available on the query type. Functions marked with the default <code>volatile</code> category are available on the mutation type:</p> FunctionMutationTypeQueryResponse <pre><code>create table account(\n  id serial primary key,\n  email varchar(255) not null\n);\n\ncreate function \"addAccount\"(email text)\n  returns int\n  volatile\n  language sql\nas $$ insert into account (email) values (email) returning id; $$;\n</code></pre> <pre><code>type Mutation {\n  addAccount(email: String!): Int\n}\n</code></pre> <pre><code>mutation {\n  addAccount(email: \"email@example.com\")\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"addAccount\": 1\n  }\n}\n</code></pre>"},{"location":"functions/#supported-return-types","title":"Supported Return Types","text":"<p>Built-in GraphQL scalar types <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code> and custom scalar types are supported as function arguments and return types. Function types returning a table or view are supported as well. Such functions implement the Node interface:</p> FunctionQueryTypeQueryResponse <pre><code>create table account(\n  id serial primary key,\n  email varchar(255) not null\n);\n\ninsert into account(email)\nvalues\n  ('a@example.com'),\n  ('b@example.com');\n\ncreate function \"accountById\"(\"accountId\" int)\n  returns account\n  stable\n  language sql\nas $$ select id, email from account where id = \"accountId\"; $$;\n</code></pre> <pre><code>type Query {\n  accountById(email: String!): Account\n}\n</code></pre> <pre><code>query {\n  accountById(accountId: 1) {\n      id\n      email\n      nodeId\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"accountById\": {\n      \"id\": 1,\n      \"email\": \"a@example.com\"\n      \"nodeId\": \"WyJwdWJsaWMiLCAiYWNjb3VudCIsIDFd\"\n    }\n  }\n}\n</code></pre> <p>Since Postgres considers a row/composite type containing only null values to be null, the result can be a little surprising in this case. Instead of an object with all columns null, the top-level field is null:</p> FunctionQueryResponse <pre><code>create table account(\n    id int,\n    email varchar(255),\n    name text null\n);\n\ninsert into account(id, email, name)\nvalues\n    (1, 'aardvark@x.com', 'aardvark'),\n    (2, 'bat@x.com', null),\n    (null, null, null);\n\ncreate function \"returnsAccountWithAllNullColumns\"()\n    returns account language sql stable\nas $$ select id, email, name from account where id is null; $$;\n</code></pre> <pre><code>query {\n  returnsAccountWithAllNullColumns {\n    id\n    email\n    name\n    __typename\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"returnsAccountWithAllNullColumns\": null\n  }\n}\n</code></pre> <p>Functions returning multiple rows of a table or view are exposed as collections.</p> FunctionQueryTypeQueryResponse <pre><code>create table \"Account\"(\n  id serial primary key,\n  email varchar(255) not null\n);\n\ninsert into \"Account\"(email)\nvalues\n  ('a@example.com'),\n  ('a@example.com'),\n  ('b@example.com');\n\ncreate function \"accountsByEmail\"(\"emailToSearch\" text)\n  returns setof \"Account\"\n  stable\n  language sql\nas $$ select id, email from \"Account\" where email = \"emailToSearch\"; $$;\n</code></pre> <pre><code>type Query {\n  accountsByEmail(\n    emailToSearch: String!\n\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: AccountFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [AccountOrderBy!]\n  ): AccountConnection\n}\n</code></pre> <pre><code>query {\n  accountsByEmail(emailToSearch: \"a@example.com\", first: 1) {\n    edges {\n      node {\n        id\n        email\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"accountsByEmail\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"email\": \"a@example.com\"\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>A set returning function with any of its argument names clashing with argument names of a collection (<code>first</code>, <code>last</code>, <code>before</code>, <code>after</code>, <code>filter</code>, or <code>orderBy</code>) will not be exposed.</p> <p>Functions accepting or returning arrays of non-composite types are also supported. In the following example, the <code>ids</code> array is used to filter rows from the <code>Account</code> table:</p> FunctionQueryTypeQueryResponse <pre><code>create table \"Account\"(\n  id serial primary key,\n  email varchar(255) not null\n);\n\ninsert into \"Account\"(email)\nvalues\n  ('a@example.com'),\n  ('b@example.com'),\n  ('c@example.com');\n\ncreate function \"accountsByIds\"(\"ids\" int[])\n  returns setof \"Account\"\n  stable\n  language sql\nas $$ select id, email from \"Account\" where id = any(ids); $$;\n</code></pre> <pre><code>type Query {\n  accountsByIds(\n    ids: Int[]!\n\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: AccountFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [AccountOrderBy!]\n  ): AccountConnection\n}\n</code></pre> <pre><code>query {\n  accountsByIds(ids: [1, 2]) {\n    edges {\n      node {\n        id\n        email\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"accountsByIds\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"id\": 1,\n            \"email\": \"a@example.com\"\n          }\n        },\n        {\n          \"node\": {\n            \"id\": 2,\n            \"email\": \"b@example.com\"\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"functions/#default-arguments","title":"Default Arguments","text":"<p>Arguments without a default value are required in the GraphQL schema, to make them optional they should have a default value.</p> FunctionQueryTypeQueryResponse <pre><code>create function \"addNums\"(a int default 1, b int default 2)\n  returns int\n  immutable\n  language sql\nas $$ select a + b; $$;\n</code></pre> <pre><code>type Query {\n  addNums(a: Int, b: Int): Int\n}\n</code></pre> <pre><code>query {\n  addNums(b: 20)\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"addNums\": 21\n  }\n}\n</code></pre> <p>If there is no sensible default, and you still want to make the argument optional, consider using the default value null.</p> FunctionQueryTypeQueryResponse <pre><code>create function \"addNums\"(a int default null, b int default null)\n    returns int\n    immutable\n    language plpgsql\nas $$\nbegin\n\n    if a is null and b is null then\n        raise exception 'a and b both can''t be null';\n    end if;\n\n    if a is null then\n        return b;\n    end if;\n\n    if b is null then\n        return a;\n    end if;\n\n    return a + b;\nend;\n$$;\n</code></pre> <pre><code>type Query {\n  addNums(a: Int, b: Int): Int\n}\n</code></pre> <pre><code>query {\n  addNums(a: 42)\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"addNums\": 42\n  }\n}\n</code></pre> <p>Currently, null defaults are only supported as simple expressions, as shown in the previous example.</p>"},{"location":"functions/#limitations","title":"Limitations","text":"<p>The following features are not yet supported. Any function using these features is not exposed in the API:</p> <ul> <li>Functions that accept a table's tuple type</li> <li>Overloaded functions</li> <li>Functions with a nameless argument</li> <li>Functions returning void</li> <li>Variadic functions</li> <li>Functions that accept or return an array of composite type</li> <li>Functions that accept or return an enum type or an array of enum type</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>First, install pgrx by running <code>cargo install --locked cargo-pgrx@version</code>, where version should be compatible with the pgrx version used by pg_graphql.</p> <p>Then clone the repo and install using:</p> <pre><code>git clone https://github.com/khulnasoft/pg_graphql.git\ncd pg_graphql\ncargo pgrx install --release\n</code></pre> <p>Before enabling the extension you need to initialize <code>pgrx</code>. The easiest way to get started is to allow <code>pgrx</code> to manage its own version/s of Postgres:</p> <pre><code>cargo pgrx init --pg17=download\n</code></pre> <p>For more advanced configuration options, like building against an existing Postgres installation from e.g. Homebrew, see the pgrx docs</p> <p>To start the database:</p> <pre><code>cargo pgrx start pg17\n</code></pre> <p>To connect:</p> <pre><code>cargo pgrx connect pg17\n</code></pre> <p>Finally, to enable the <code>pg_graphql</code> extension in Postgres, execute the <code>create extension</code> statement. This extension creates its own schema/namespace named <code>graphql</code> to avoid naming conflicts.</p> <pre><code>create extension pg_graphql;\n</code></pre> <p>These steps ensure that <code>pgrx</code> is properly initialized, and the database is started and connected before attempting to install and use the <code>pg_graphql</code> extension.</p>"},{"location":"khulnasoft/","title":"Khulnasoft","text":"<p>The Khulnasoft GraphQL API is automatically reflected from your database's schema using pg_graphql. It supports:</p> <ul> <li>Basic CRUD operations (Create/Read/Update/Delete)</li> <li>Support for Tables, Views, Materialized Views, and Foreign Tables</li> <li>Arbitrarily deep relationships among tables/views</li> <li>User defined computed fields</li> <li>Postgres' security model - including Row Level Security, Roles, and Grants</li> </ul> <p>All requests resolve in a single round-trip leading to fast response times and high throughput.</p> <p>If you haven't created a Khulnasoft project, do that here so you can follow along with the guide.</p>"},{"location":"khulnasoft/#quickstart","title":"Quickstart","text":"<p><code>https://&lt;PROJECT_REF&gt;.khulnasoft.co/graphql/v1</code> is your project's GraphQL API endpoint. See PROJECT_REF for instructions on finding your project's reference. Note that the url does not allow a trailing <code>/</code>.</p> <p>To access the API you MUST provide your project's API key as a header in every request. For example see line 2 of the cURL request below.</p> <pre><code>curl -X POST https://&lt;PROJECT_REF&gt;.khulnasoft.co/graphql/v1 \\\n    -H 'apiKey: &lt;API_KEY&gt;' \\\n    -H 'Content-Type: application/json' \\\n    --data-raw '{\"query\": \"{ accountCollection(first: 1) { edges { node { id } } } }\", \"variables\": {}}'\n</code></pre> <p>For user authentication, pass an <code>Authorization</code> header e.g. <pre><code>    -H 'Authorization: Bearer &lt;JWT&gt;'\n</code></pre> See the auth docs to understand how to sign-up/sign-in users to your application and retrieve a JWT. The apollo and relay guides also include complete examples of using Khulnasoft Auth with GraphQL. Khulnasoft Auth works with row level security (RLS) allowing you to control which users can access tables/rows.</p> <p>The fastest way to get started with GraphQL on Khulnasoft is using the GraphQL IDE (GraphiQL) built directly into Khulnasoft Studio.</p>"},{"location":"khulnasoft/#clients","title":"Clients","text":"<p>If you're new to GraphQL or Khulnasoft, we strongly recommend starting with Khulnasoft GraphQL by following the Khulnasoft Studio guide.</p> <p>For more experienced users, or when you're ready to productionize your application, access the API using khulnasoft-js, GraphiQL, or any HTTP client, for example cURL.</p>"},{"location":"khulnasoft/#khulnasoft-studio","title":"Khulnasoft Studio","text":"<p>The easiest way to make a GraphQL request with Khulnasoft is to use Khulnasoft Studio's builtin GraphiQL IDE. You can access GraphiQL here by selecting the relevant project. Alternatively, navigate there within Studio at <code>API Docs &gt; GraphQL &gt; GraphiQL</code>.</p> <p></p> <p>Type queries in the central query editor and use the green icon to submit requests to the server. Results are shown in the output display to the right of the editor.</p> <p>To explore the API visually, select the docs icon shown below and navigate through each type to see how they connect to the Graph.</p> <p></p> <p>pg_graphql mirrors the structure of the project's SQL schema in the GraphQL API. If your project is new and empty, the GraphQL API will be empty as well, with the exception of basic introspection types. For a more interesting result, go to the SQL or table editor and create a table.</p> <p></p> <p>Head back to GraphiQL to see the new table reflected in your GraphQL API's Query and Mutation types.</p> <p></p> <p>If you'd like your type and field names to match the GraphQL convention of <code>PascalCase</code> for types and <code>camelCase</code> for fields, check out the pg_graphql inflection guide.</p>"},{"location":"khulnasoft/#http-request","title":"HTTP Request","text":"<p>To access the GraphQL API over HTTP, first collect your project reference and API Key.</p>"},{"location":"khulnasoft/#curl","title":"cURL","text":"<p>To hit the Khulnasoft GraphQL API using cURL, submit a <code>POST</code> request to your GraphQL API's URL shown below, substituting in your PROJECT_REF and passing the project's API_KEY as the <code>apiKey</code> header:</p> <pre><code>curl -X POST https://&lt;PROJECT_REF&gt;.khulnasoft.co/graphql/v1 \\\n    -H 'apiKey: &lt;API_KEY&gt;' \\\n    -H 'Content-Type: application/json' \\\n    --data-raw '{\"query\": \"{ accountCollection(first: 1) { edges { node { id } } } }\", \"variables\": {}}'\n</code></pre> <p>In that example, the GraphQL <code>query</code> is <pre><code>{\n  accountCollection(first: 1) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre></p> <p>and there are no <code>variables</code> <pre><code>{}\n</code></pre></p>"},{"location":"khulnasoft/#khulnasoft-js","title":"khulnasoft-js","text":"<p>The JS ecosystem supports multiple prominent GraphQL frameworks. khulnasoft-js is unopinionated about your GraphQL tooling and can integrate with all of them.</p> <p>For an example integration, check out the Relay guide, complete with Khulnasoft Auth support.</p>"},{"location":"khulnasoft/#graphiql","title":"GraphiQL","text":"<p>If you'd prefer to connect to Khulnasoft GraphQL using an external IDE like GraphiQL, save the HTML snippet below as <code>khulnasoft_graphiql.html</code> and open it in your browser. Be sure to substitute in your PROJECT_REF and API_KEY beneath the <code>EDIT BELOW</code> comment:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;GraphiQL&lt;/title&gt;\n    &lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/2.4.7/graphiql.css\" rel=\"stylesheet\" /&gt;\n  &lt;/head&gt;\n  &lt;body style=\"margin: 0;\"&gt;\n    &lt;div id=\"graphiql\" style=\"height: 100vh;\"&gt;&lt;/div&gt;\n    &lt;script crossorigin src=\"https://unpkg.com/react@18/umd/react.production.min.js\"&gt;&lt;/script&gt;\n    &lt;script crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;\n    &lt;script\n      crossorigin\n      src=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/2.4.7/graphiql.js\"\n    &gt;&lt;/script&gt;\n    &lt;script&gt;\n\n      ////////////////\n      // EDIT BELOW //\n      ////////////////\n\n      const fetcher = GraphiQL.createFetcher({\n        url: 'https://&lt;PROJECT_REF&gt;.khulnasoft.co/graphql/v1',\n        headers: {\n          \"apiKey\": \"&lt;API_KEY&gt;\",\n        }\n      });\n      ReactDOM.render(\n        React.createElement(GraphiQL, { fetcher: fetcher }),\n        document.getElementById('graphiql'),\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"khulnasoft/#schema-table-visibility","title":"Schema &amp; Table Visibility","text":"<p>pg_graphql uses Postgres' <code>search_path</code> and permissions system to determine which schemas and entities are exposed in the GraphQL schema. By default on Khulnasoft, tables, views, and functions in the <code>public</code> schema are visible to anonymous (<code>anon</code>) and logged in (<code>authenticated</code>) roles.</p>"},{"location":"khulnasoft/#remove-a-table-from-the-api","title":"Remove a Table from the API","text":"<p>To remove a table from the GraphQL API, you can revoke permission on that table from the the relevant role. For example, to remove table <code>foo</code> from the API for anonymous users you could run:</p> <pre><code>revoke all on table public.foo from anon;\n</code></pre> <p>You can similarly revoke permissions using the more granular <code>insert</code>, <code>update</code>, <code>delete</code>, and <code>truncate</code> permissions to remove individual entrypoints in the GraphQL API. For example, revoking <code>update</code> permission removes the <code>updateFooCollection</code> entrypoing in the API's <code>Mutation</code> type.</p>"},{"location":"khulnasoft/#add-a-schema-to-the-api","title":"Add a Schema to the API","text":"<p>Adding a schema to the GraphQL API is a two step process.</p> <p>First, we need to add the new schema to the API search path. In the example below, we add a comma separated value for the new <code>app</code> schema:</p> <p></p> <p>Next, make sure the schema and entities (tables/views/functions) that you intend to expose are accessible by the relevant roles. For example, to match permissions from the public schema:</p> <pre><code>grant usage on schema app to anon, authenticated, service_role;\ngrant all privileges on all tables in schema app to anon, authenticated, service_role;\ngrant all privileges on all routines in schema app to anon, authenticated, service_role;\ngrant all privileges on all sequences in schema app to anon, authenticated, service_role;\nalter default privileges for role postgres in schema app grant all on tables to anon, authenticated, service_role;\nalter default privileges for role postgres in schema app grant all on routines to anon, authenticated, service_role;\nalter default privileges for role postgres in schema app grant all on sequences to anon, authenticated, service_role;\n</code></pre> <p>Note that in practice you likely prefer a more secure set of permissions, particularly for anonymous API users.</p>"},{"location":"khulnasoft/#version-management","title":"Version Management","text":"<p>To maximize stability, you are in control of when to upgrade your GraphQL API. To see which version of pg_graphql you have, and the highest upgrade version available, execute:</p> <pre><code>select * from pg_available_extensions where name = 'pg_graphql'\n</code></pre> <p>Which returns a table, for example:</p> name default_version installed_version comment pg_graphql 1.2.0 1.1.0 GraphQL support <p>The <code>default_version</code> is the highest version available on your database. The <code>installed_version</code> is the version currently enabled in your database. If the two differ, as in the example, you can upgrade your installed version by running:</p> <pre><code>drop extension pg_graphql;   -- drop version 1.1.0\ncreate extension pg_graphql; -- install default version 1.2.0\n</code></pre> <p>To upgrade your GraphQL API with 0 downtime.</p> <p>When making a decision to upgrade, you can review features of the upgraded version in the changelog.</p> <p>Always test a new version of pg_graphql extensively on a development or staging instance before updating your production instance. pg_graphql follows SemVer, which makes API backwards compatibility relatively safe for minor and patch updates. Even so, it's critical to verify that changes do not negatively impact the specifics of your project's API in other ways, e.g. requests/sec or CPU load.</p>"},{"location":"khulnasoft/#local-development","title":"Local Development","text":"<p>When starting a local project through the Khulnasoft CLI, the output of <code>khulnasoft start</code> provides the information needed to call the GraphQL API directly. You can also use the Khulnasoft Studio url to access the builtin GraphiQL IDE.</p> <pre><code>&gt; khulnasoft start\n...\n\nStarted khulnasoft local development setup.\n\n     GraphQL URL: http://localhost:54321/graphql/v1  &lt;-- GraphQL endpoint\n          DB URL: ...\n      Studio URL: http://localhost:54323             &lt;-- Khulnasoft Studio\n    Inbucket URL: ...\n      JWT secret: ...\n        anon key: eyJhbGciOiJIUzI1...&lt;truncated&gt;     &lt;-- API_KEY\nservice_role key: ...\n</code></pre>"},{"location":"khulnasoft/#term-reference","title":"Term Reference","text":""},{"location":"khulnasoft/#project-reference-project_ref","title":"Project Reference (PROJECT_REF)","text":"<p>Your Khulnasoft project reference or PROJECT_REF is a 20 digit unique identifier for your project, for example <code>bvykdyhlwawojivopztl</code>. The project reference is used throughout your khulnasoft application including the project's API URL. You can find the project reference in by logging in to Khulnasoft Studio and navigating to <code>Settings &gt; General &gt; Project Settings &gt; Reference ID</code></p> <p></p>"},{"location":"khulnasoft/#api-key-api_key","title":"API Key (API_KEY)","text":"<p>Your Khulnasoft API Key is a public value that must be sent with every API request. The key is visible in Khulnasoft Studio at <code>Settings &gt; API &gt; Project API keys</code></p> <p></p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>If you are new to the project, start here.</p> <p>The easiest way to try <code>pg_graphql</code> is to run the interactive GraphiQL IDE demo. The demo environment launches a database, webserver and the GraphiQL IDE/API explorer with a small pre-populated schema.</p> <p>Requires:</p> <ul> <li>git</li> <li>docker-compose</li> </ul> <p>First, clone the repo</p> <pre><code>git clone https://github.com/khulnasoft/pg_graphql.git\ncd pg_graphql\n</code></pre> <p>Next, launch the demo with docker-compose.</p> <pre><code>docker-compose up\n</code></pre> <p>Finally, access GraphiQL at <code>http://localhost:4000/</code>.</p> <p></p>"},{"location":"security/","title":"Security","text":"<p><code>pg_graphql</code> fully respects builtin PostgreSQL role and row security.</p>"},{"location":"security/#tablecolumn-visibility","title":"Table/Column Visibility","text":"<p>Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL role permissions. Revoking <code>SELECT</code> access from the user/role executing queries removes that entity from the visible schema.</p> <p>For example: <pre><code>revoke all privileges on public.\"Account\" from api_user;\n</code></pre></p> <p>removes the <code>Account</code> GraphQL type.</p> <p>Similarly, revoking <code>SELECT</code> access on a table's column will remove that field from the associated GraphQL type/s.</p> <p>The permissions <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> all impact the relevant sections of the GraphQL schema.</p>"},{"location":"security/#row-visibility","title":"Row Visibility","text":"<p>Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies.</p>"},{"location":"sql_interface/","title":"SQL Interface","text":"<p>pg_graphql's public facing SQL interface consists of a single SQL function to resolve GraphQL requests. All other entities in the <code>graphql</code> schema are private.</p>"},{"location":"sql_interface/#graphqlresolve","title":"graphql.resolve","text":""},{"location":"sql_interface/#description","title":"description","text":"<p>Resolves a GraphQL query, returning JSONB.</p>"},{"location":"sql_interface/#signature","title":"signature","text":"<pre><code>graphql.resolve(\n    -- graphql query/mutation\n    query text,\n    -- json key/values pairs for variables\n    variables jsonb default '{}'::jsonb,\n    -- the name of the graphql operation in *query* to execute\n    \"operationName\" text default null,\n    -- extensions to include in the request\n    extensions jsonb default null,\n)\n    returns jsonb\n\n    strict\n    volatile\n    parallel safe\n    language plpgsql\n</code></pre>"},{"location":"sql_interface/#usage","title":"usage","text":"<pre><code>-- Create the extension\ngraphqldb= create extension pg_graphql;\nCREATE EXTENSION\n\n-- Create an example table\ngraphqldb= create table book(id int primary key, title text);\nCREATE TABLE\n\n-- Insert a record\ngraphqldb= insert into book(id, title) values (1, 'book 1');\nINSERT 0 1\n\n-- Query the table via GraphQL\ngraphqldb= select graphql.resolve($$\nquery {\n  bookCollection {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n$$);\n\n             resolve\n----------------------------------------------------------------------\n{\"data\": {\"bookCollection\": {\"edges\": [{\"node\": {\"id\": 1}}]}}, \"errors\": []}\n</code></pre>"},{"location":"usage_with_apollo/","title":"Usage with Apollo","text":"<p>This guide will show you how to use pg_graphql with Apollo and GraphQL Code Generator for type-safe GraphQL queries in your React application.</p>"},{"location":"usage_with_apollo/#apollo-setup","title":"Apollo Setup","text":""},{"location":"usage_with_apollo/#pre-requisites","title":"Pre-requisites","text":"<ol> <li>Follow the Apollo Getting Started Guide.</li> <li>Follow the GraphQL Code Generator Installation Guide.</li> </ol>"},{"location":"usage_with_apollo/#configuring-graphql-code-generator","title":"Configuring GraphQL Code Generator","text":"<p>Modify your <code>codegen.ts</code> file to reflect the following:</p> <pre><code>import type { CodegenConfig } from '@graphql-codegen/cli'\nimport { addTypenameSelectionDocumentTransform } from '@graphql-codegen/client-preset'\n\nconst config: CodegenConfig = {\n  schema: 'http://localhost:54321/graphql/v1', // Using the local endpoint, update if needed\n  documents: 'src/**/*.tsx',\n  overwrite: true,\n  ignoreNoDocuments: true,\n  generates: {\n    'src/gql/': {\n      preset: 'client',\n      documentTransforms: [addTypenameSelectionDocumentTransform],\n      plugins: [],\n      config: {\n        scalars: {\n          UUID: 'string',\n          Date: 'string',\n          Time: 'string',\n          Datetime: 'string',\n          JSON: 'string',\n          BigInt: 'string',\n          BigFloat: 'string',\n          Opaque: 'any',\n        },\n      },\n    },\n  },\n  hooks: {\n    afterAllFileWrite: ['npm run prettier'], // optional\n  },\n}\n\nexport default config\n</code></pre>"},{"location":"usage_with_apollo/#configuring-apollo-client","title":"Configuring Apollo Client","text":"<p>This example uses Khulnasoft for the GraphQL server, but pg_graphql can be used independently.</p> <pre><code>import {\n  ApolloClient,\n  InMemoryCache,\n  createHttpLink,\n  defaultDataIdFromObject\n} from '@apollo/client'\nimport { setContext } from '@apollo/client/link/context'\nimport { relayStylePagination } from '@apollo/client/utilities'\nimport khulnasoft from './khulnasoft'\n\nconst cache = new InMemoryCache({\n  dataIdFromObject(responseObject) {\n    if ('nodeId' in responseObject) {\n      return `${responseObject.nodeId}`\n    }\n\n    return defaultDataIdFromObject(responseObject)\n  },\n  possibleTypes: { Node: ['Todos'] } // optional, but useful to specify supertype-subtype relationships\n  typePolicies: {\n    Query: {\n      fields: {\n        todosCollection: relayStylePagination(), // example of paginating a collection\n        node: {\n          read(_, { args, toReference }) {\n            const ref = toReference({\n              nodeId: args?.nodeId,\n            })\n\n            return ref\n          },\n        },\n      },\n    },\n  },\n})\n\nconst httpLink = createHttpLink({\n  uri: 'http://localhost:54321/graphql/v1',\n})\n\nconst authLink = setContext(async (_, { headers }) =&gt; {\n  const token = (await khulnasoft.auth.getSession()).data.session?.access_token\n\n  return {\n    headers: {\n      ...headers,\n      Authorization: token ? `Bearer ${token}` : '',\n    },\n  }\n})\n\nconst apolloClient = new ApolloClient({\n  link: authLink.concat(httpLink),\n  cache,\n})\n\nexport default apolloClient\n</code></pre> <ul> <li><code>typePolicies.Query.fields.node</code> is also optional, but useful for reducing cache misses. Learn more about Redirecting to cached data.</li> </ul>"},{"location":"usage_with_apollo/#example-query","title":"Example Query","text":"<pre><code>import { useQuery } from '@apollo/client'\nimport { graphql } from './gql'\n\nconst allTodosQueryDocument = graphql(/* GraphQL */ `\n  query AllTodos($cursor: Cursor) {\n    todosCollection(first: 10, after: $cursor) {\n      edges {\n        node {\n          nodeId\n          title\n        }\n      }\n      pageInfo {\n        endCursor\n        hasNextPage\n      }\n    }\n  }\n`)\n\nconst TodoList = () =&gt; {\n  const { data, fetchMore } = useQuery(allTodosQueryDocument)\n\n  return (\n    &lt;&gt;\n      {data?.thingsCollection?.edges.map(({ node }) =&gt; (\n        &lt;Todo key={node.nodeId} title={node.title} /&gt;\n      ))}\n      {data?.thingsCollection?.pageInfo.hasNextPage &amp;&amp; (\n        &lt;Button\n          onClick={() =&gt; {\n            fetchMore({\n              variables: {\n                cursor: data?.thingsCollection?.pageInfo.endCursor,\n              },\n            })\n          }}\n        &gt;\n          Load More\n        &lt;/Button&gt;\n      )}\n    &lt;/&gt;\n  )\n}\n\nexport default TodoList\n</code></pre>"},{"location":"usage_with_relay/","title":"Usage with Relay","text":"<p>pg_graphql implements the GraphQL Global Object Identification Specification (<code>Node</code> interface) and the GraphQL Cursor Connections Specification to be compatible with Relay.</p>"},{"location":"usage_with_relay/#relay-setup","title":"Relay Setup","text":""},{"location":"usage_with_relay/#pre-requisites","title":"Pre-requisites","text":"<p>Follow the Relay Installation Guide.</p>"},{"location":"usage_with_relay/#configuring-the-relay-compiler","title":"Configuring the Relay Compiler","text":"<p>Modify your <code>relay.config.js</code> file to reflect the following:</p> <pre><code>module.exports = {\n  // standard relay config options\n  src: './src',\n  language: 'typescript',\n  schema: './data/schema.graphql',\n  exclude: ['**/node_modules/**', '**/__mocks__/**', '**/__generated__/**'],\n  // pg_graphql specific options\n  schemaConfig: {\n    nodeInterfaceIdField: 'nodeId',\n    nodeInterfaceIdVariableName: 'nodeId',\n  },\n  customScalarTypes: {\n    UUID: 'string',\n    Datetime: 'string',\n    JSON: 'string',\n    BigInt: 'string',\n    BigFloat: 'string',\n    Opaque: 'any',\n  },\n}\n</code></pre> <ul> <li><code>schemaConfig</code> tells the Relay compiler where to find the <code>nodeId</code> field on the <code>node</code> interface</li> <li><code>customScalarTypes</code> will improve Relay's type emission</li> </ul> <p>Note</p> <p>For Relay versions older than v16.2.0, it should be named <code>customScalars</code> instead.</p>"},{"location":"usage_with_relay/#configuring-your-relay-environment","title":"Configuring your Relay Environment","text":"<p>This example uses Khulnasoft for the GraphQL server, but pg_graphql can be used independently.</p> <pre><code>import {\n  Environment,\n  FetchFunction,\n  Network,\n  RecordSource,\n  Store,\n} from 'relay-runtime'\n\nimport khulnasoft, { KHULNASOFT_ANON_KEY, KHULNASOFT_URL } from './khulnasoft'\n\nconst fetchQuery: FetchFunction = async (operation, variables) =&gt; {\n  const {\n    data: { session },\n  } = await khulnasoft.auth.getSession()\n\n  const response = await fetch(`${KHULNASOFT_URL}/graphql/v1`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      apikey: KHULNASOFT_ANON_KEY,\n      Authorization: `Bearer ${session?.access_token ?? KHULNASOFT_ANON_KEY}`,\n    },\n    body: JSON.stringify({\n      query: operation.text,\n      variables,\n    }),\n  })\n\n  return await response.json()\n}\n\nconst network = Network.create(fetchQuery)\nconst store = new Store(new RecordSource())\n\nconst environment = new Environment({\n  network,\n  store,\n  getDataID: (node) =&gt; node.nodeId,\n  missingFieldHandlers: [\n    {\n      handle(field, _record, argValues) {\n        if (field.name === 'node' &amp;&amp; 'nodeId' in argValues) {\n          // If field is node(nodeId: $nodeId), look up the record by the value of $nodeId\n          return argValues.nodeId\n        }\n\n        return undefined\n      },\n      kind: 'linked',\n    },\n  ],\n})\n\nexport default environment\n</code></pre> <ul> <li><code>getDataID</code> is the most important option to add, as it tells Relay how to store data correctly in the cache.</li> <li><code>missingFieldHandlers</code> is optional in this example but helps with Rendering Partially Cached Data.</li> </ul>"},{"location":"usage_with_relay/#pagination","title":"Pagination","text":"<p>Say you are working on a Todo app and want to add pagination. You can use <code>@connection</code> and <code>@prependNode</code> to do this.</p> <p>Fragment passed to <code>usePaginationFragment()</code></p> <pre><code>fragment TodoList_query on Query\n@argumentDefinitions(\n  cursor: { type: \"Cursor\" }\n  count: { type: \"Int\", defaultValue: 20 }\n)\n@refetchable(queryName: \"TodoListPaginationQuery\") {\n  todosCollection(after: $cursor, first: $count)\n    @connection(key: \"TodoList_query_todosCollection\") {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    edges {\n      cursor\n      node {\n        nodeId\n        ...TodoItem_todos\n      }\n    }\n  }\n}\n</code></pre> <p>Mutation to create a new Todo</p> <pre><code>mutation TodoCreateMutation($input: TodosInsertInput!, $connections: [ID!]!) {\n  insertIntoTodosCollection(objects: [$input]) {\n    affectedCount\n    records @prependNode(connections: $connections, edgeTypeName: \"TodosEdge\") {\n      ...TodoItem_todos\n    }\n  }\n}\n</code></pre> <p>Code to call the mutation</p> <pre><code>import { ConnectionHandler, graphql, useMutation } from 'react-relay'\n\n// inside a React component\nconst [todoCreateMutate, isMutationInFlight] =\n  useMutation&lt;TodoCreateMutation&gt;(CreateTodoMutation)\n\n// inside your create todo function\nconst connectionID = ConnectionHandler.getConnectionID(\n  'root',\n  'TodoList_query_todosCollection'\n)\n\ntodoCreateMutate({\n  variables: {\n    input: {\n      // ...new todo data\n    },\n    connections: [connectionID],\n  },\n})\n</code></pre>"},{"location":"views/","title":"Views","text":"<p>Views, materialized views, and foreign tables can be exposed with pg_graphql.</p>"},{"location":"views/#primary-keys-required","title":"Primary Keys (Required)","text":"<p>A primary key is required for an entity to be reflected in the GraphQL schema. Tables can define primary keys with SQL DDL, but primary keys are not available for views, materialized views, or foreign tables. For those entities, you can set a \"fake\" primary key with a comment directive. <pre><code>{\"primary_key_columns\": [&lt;column_name_1&gt;, ..., &lt;column_name_n&gt;]}\n</code></pre></p> <p>For example:</p> <p><pre><code>create view \"Person\" as\n  select\n    id,\n    name\n  from\n    \"Account\";\n\ncomment on view \"Person\" is e'@graphql({\"primary_key_columns\": [\"id\"]})';\n</code></pre> tells pg_graphql to treat <code>\"Person\".id</code> as the primary key for the <code>Person</code> entity resulting in the following GraphQL type:</p> <pre><code>type Person {\n  nodeId: ID!\n  id: Int!\n  name: String!\n}\n</code></pre> <p>Warning</p> <p>Values of the primary key column/s must be unique within the table. If they are not unique, you will experience inconsistent behavior with <code>ID!</code> types, sorting, and pagination.</p> <p>Updatable views are reflected in the <code>Query</code> and <code>Mutation</code> types identically to tables. Non-updatable views are read-only and accessible via the <code>Query</code> type only.</p>"},{"location":"views/#relationships","title":"Relationships","text":"<p>pg_graphql identifies relationships among entities by inspecting foreign keys. Views, materialized views, and foreign tables do not support foreign keys. For this reason, relationships can also be defined in comment directive using the structure:</p> <pre><code>{\n  \"foreign_keys\": [\n    {\n      \"local_name\": \"foo\", // optional\n      \"local_columns\": [\"account_id\"],\n      \"foreign_name\": \"bar\", // optional\n      \"foreign_schema\": \"public\",\n      \"foreign_table\": \"account\",\n      \"foreign_columns\": [\"id\"]\n    }\n  ]\n}\n</code></pre> <p>For example:</p> <p><pre><code>create table \"Account\"(\n  id serial primary key,\n  name text not null\n);\n\ncreate table \"EmailAddress\"(\n  id serial primary key,\n  \"accountId\" int not null, -- note: no foreign key\n  \"isPrimary\" bool not null,\n  address text not null\n);\n\ncomment on table \"EmailAddress\" is e'\n    @graphql({\n        \"foreign_keys\": [\n          {\n            \"local_name\": \"addresses\",\n            \"local_columns\": [\"accountId\"],\n            \"foreign_name\": \"account\",\n            \"foreign_schema\": \"public\",\n            \"foreign_table\": \"Account\",\n            \"foreign_columns\": [\"id\"]\n          }\n        ]\n    })';\n</code></pre> defines a relationship equivalent to the following foreign key <pre><code>alter table \"EmailAddress\"\n  add constraint fkey_email_address_to_account\n  foreign key (\"accountId\")\n  references \"Account\" (\"id\");\n\ncomment on constraint fkey_email_address_to_account\n  on \"EmailAddress\"\n  is E'@graphql({\"foreign_name\": \"account\", \"local_name\": \"addresses\"})';\n</code></pre></p> <p>yielding the GraphQL types:</p> <pre><code>type Account {\n  nodeId: ID!\n  id: Int!\n  name: String!\n  addresses(\n    after: Cursor,\n    before: Cursor,\n    filter: EmailAddressFilter,\n    first: Int,\n    last: Int,\n    orderBy: [EmailAddressOrderBy!]\n  ): EmailAddressConnection\n}\n\ntype EmailAddress {\n  nodeId: ID!\n  id: Int!\n  isPrimary: Boolean!\n  address: String!\n  accountId: Int!\n  account: Account!\n}\n</code></pre>"}]}